{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/codecamp_blog_9/",
    "result": {"data":{"cur":{"id":"6cd52fba-d645-508a-b1ca-9649a89144ef","html":"<h3 id=\"optimistic-ui\" style=\"position:relative;\"><a href=\"#optimistic-ui\" aria-label=\"optimistic ui permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optimistic-UI</h3>\n<p>낙관적 UI라고도 한다. 보통 mutation을 날리고 응답을 받을 때까지 기다려야한다. 하지만 그렇게 하지 않고 바로 사용자에게 UI가 보여지는 것처럼 속이는 것을 Optimistic UI라고 한다.</p>\n<ol>\n<li>성공 확률이 99%인 요청에 적용 2. 혹시 실패하더라도, 큰 영향이 없는 요청에 적용한다.\n예를 들어, 결제에 달아놓으면 큰일남 ㅎ</li>\n</ol>\n<p>게시판 좋아요 기능에 **<code class=\"language-text\">Optimistic-UI</code>**를 적용한다고 해보자.</p>\n<ol>\n<li>브라우저에서 백엔드로 API를 요청한다.</li>\n<li>브라우저에서 useQuery를 날리면 바로 백엔드로 가는 게 아니라 apolloCache를 먼저 확인한다. (cache-first가 default여서)</li>\n<li>캐시값을 받아오는 걸 기다리지 않고 바로 화면에서 +1,, (<strong>Optimisic-UI</strong>)</li>\n<li>cache 확인하고 백엔드로 api 넘어가서 DB에서 데이터를 찾아, 좋아요 +1 올려줌</li>\n<li>apolloCashe를 백엔드에서 받아온 데이터 값으로 덮어씌운다.</li>\n</ol>\n<h3 id=\"scraping-crawling\" style=\"position:relative;\"><a href=\"#scraping-crawling\" aria-label=\"scraping crawling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scraping, Crawling</h3>\n<ul>\n<li>Scraping : html 코드 긁어오기 (한번만)\n<a href=\"https://www.npmjs.com/package/cheerio\">cheerio</a></li>\n<li>Crawling : html 코드 긁어오기 (정기적으로)\n<a href=\"https://www.npmjs.com/package/puppeteer\">puppeteer</a></li>\n</ul>\n<p><strong>API 요청하는 방법(REST API endpoint)</strong></p>\n<ol>\n<li>브라우저(받은 reponse가 html이면 해석해서 렌더링하는 능력이 있음) - 얘도 GET 요청</li>\n<li>postman</li>\n<li>terminal curl ~</li>\n</ol>\n<p>스크랩핑을 할 때 <strong>브라우저</strong>에서는 <code class=\"language-text\">CORS 정책</code>때문에 막힐 수 있음.</p>\n<p><strong>CORS</strong></p>\n<ul>\n<li>모바일</li>\n<li>백엔드에서 우회해서 요청하는 방법(<strong>proxy server</strong>)</li>\n</ul>\n<h3 id=\"ssr이-필요한-상황\" style=\"position:relative;\"><a href=\"#ssr%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%83%81%ED%99%A9\" aria-label=\"ssr이 필요한 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSR이 필요한 상황</h3>\n<p>중고마켓에서는 각 상품에 대한 og를 하드코딩할 수가 없다.(동적 페이지)</p>\n<p>⇒ <code class=\"language-text\">**useQuery**</code>로 받아와야함. 하지만, 이렇게 만들면 초기 렌더링을 했을 때는 백엔드 요청을 하지 않기 때문에 메타태그가 비어있다.</p>\n<p>따라서, html을 브라우저에 보내주기 전에 먼저 프론트엔드 서버에서 로직을 실행할 수 있게 한다.(axios, useQuery, useMutation 등) ⇒ <code class=\"language-text\">**getServerSideProps()**</code></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/df65986a-e73f-4984-8b01-29acb0f95d70/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-18_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.14.50.png\" alt=\"스크린샷 2022-08-18 오후 1.14.50.png\"></p>\n<p>서버 사이드 렌더링이 필요한 이유 중 **검색 엔진 최적화(SEO)**가 가장 많이 언급된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useMutation<span class=\"token punctuation\">,</span>gql<span class=\"token punctuation\">,</span>useQuery <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"@apollo/client\"</span>\n\n<span class=\"token comment\">//좋아요 갯수 가지고 오는 api _ 게시글 조회 api에서 좋아요 갯수만 뽑아 옵니다.</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">FETCH_BOARD</span> <span class=\"token operator\">=</span> gql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n\tquery fetchBoard($boardId: ID!){\n\t\tfetchBoard(boardId: $boardId){\n\t\t\t_id\n\t\t\tlikeCount\n\t\t}\n\t}\n</span><span class=\"token template-punctuation string\">`</span></span>\n\n<span class=\"token comment\">//좋아요 카운트 올리는 api</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">LIKE_BOARD</span> <span class=\"token operator\">=</span> gql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n\tmutation likeBoard($boardId:ID!){\n\t\tlikeBoard(boardId:$boardId)\n\t}\n</span><span class=\"token template-punctuation string\">`</span></span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>likeBoard<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useMutation</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LIKE_BOARD</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useQuery</span><span class=\"token punctuation\">(</span><span class=\"token constant\">FETCH_BOARD</span><span class=\"token punctuation\">,</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"token punctuation\">{</span>variables <span class=\"token operator\">:</span><span class=\"token punctuation\">{</span>boardId <span class=\"token operator\">:</span> <span class=\"token string\">\"게시글 아이디 넣어주세요!\"</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onClickOptimisticUI</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">//likeBoard 뮤테이션 함수를 실행하겠습니다.</span>\n\t\t<span class=\"token function\">likeBoard</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n\t\t\tvariables <span class=\"token operator\">:</span><span class=\"token punctuation\">{</span>\n\t\t\t\tboardId <span class=\"token operator\">:</span> <span class=\"token string\">\"게시글 아이디 넣어주세요!\"</span>\n\t\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n\t\t<span class=\"token comment\">// 응답을 받고난 후 받아온 응답을 다시 fetch 해줍니다. -> 느리고 효율적이지 못합니다.(백엔드에 요청을 한번더 해야하고 받아올때 까지 기다려야 합니다.)</span>\n\t\t<span class=\"token comment\">//refetchQueries: [</span>\n\t\t<span class=\"token comment\">//\t{</span>\n\t\t<span class=\"token comment\">//\t\tquery: FETCH_BOARD,</span>\n\t\t<span class=\"token comment\">//\t\tvariables : {\tboardId : \"//게시글 아이디 넣어주세요!\" }</span>\n\t\t<span class=\"token comment\">//\t}</span>\n\t\t<span class=\"token comment\">// ]</span>\n\n\t\t<span class=\"token operator\">**</span><span class=\"token comment\">//옵티미스틱 UI -> 캐시를 바꾸고 캐시값을 받아오는걸 기다리지 않고 바로 바꿔줍니다.**</span>\n\t\t<span class=\"token operator\">**</span>optimisticResponse<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n\t\t\tlikeBoard <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>data<span class=\"token operator\">?.</span>fetchBoard<span class=\"token punctuation\">.</span>likeCount <span class=\"token operator\">||</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token operator\">**</span>\n\t\t<span class=\"token operator\">**</span><span class=\"token comment\">// apollo 캐시를 직접 수정을 할 수 있었습니다.(백엔드 캐시가 아닙니다.) -> 느리지만 효율적입니다. (백엔드에 요청은 안하지만, 받아올때까지 기다려줘야 합니다.)</span>\n\t\t\t<span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cache<span class=\"token punctuation\">,</span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token comment\">// 이전 시간에는 modify를 사용했지만, 오늘은 writeQuery를 사용해보겠습니다.</span>\n\t\t\t\tcache<span class=\"token punctuation\">.</span><span class=\"token function\">writeQuery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n\t\t\t\t\tquery <span class=\"token operator\">:</span> <span class=\"token constant\">FETCH_BOARD</span><span class=\"token punctuation\">,</span>\n\t\t\t\t\tvariables <span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>boardId<span class=\"token operator\">:</span><span class=\"token string\">'게시글 아이디 넣어주세요!'</span><span class=\"token punctuation\">}</span>\n\t\t\t\t\t<span class=\"token comment\">//어떻게 수정할 것인지는 아래에 적어줍니다.</span>\n\t\t\t\t\tdata<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t\t\tfetchBoard<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t\t\t\t_id <span class=\"token operator\">:</span> <span class=\"token string\">'게시글 아이디 넣어주세요!'</span><span class=\"token punctuation\">,</span>\n\t\t\t\t\t\t\t__typename <span class=\"token operator\">:</span> <span class=\"token string\">\"Board\"</span>\n\t\t\t\t\t\t\tlikeCount<span class=\"token operator\">:</span> data<span class=\"token operator\">?.</span>likeBoard\n\t\t\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">}</span><span class=\"token operator\">**</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>\n\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">옵티미스틱 UI</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">현재카운트(좋아요):</span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">.</span>fetchBoard<span class=\"token punctuation\">.</span>likeCount<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>onClickOptimisticUI<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">좋아요 올리기!!</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n\t<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","excerpt":"Optimistic-UI 낙관적 UI라고도 한다. 보통 mutation을 날리고 응답을 받을 때까지 기다려야한다. 하지만 그렇게 하지 않고 바로 사용자에게 UI가 보여지는 것처럼 속이는 것을 Optimistic UI라고 한다. 성공 확률이 99%인 요청에 적용 2. 혹시 실패하더라도, 큰 영향이 없는 요청에 적용한다.\n예를 들어, 결제에 달아놓으면 큰일남 ㅎ 게시판 좋아요 기능에 ****를 적용한다고 해보자. 브라우저에서 백엔드로 API를 요청한다. 브라우저에서 useQuery를 날리면 바로 백엔드로 가는 게 아니라 apolloCache를 먼저 확인한다. (cache-first가 default여서) 캐시값을 받아오는 걸 기다리지 않고 바로 화면에서 +1,, (Optimisic-UI) cache 확인하고 백엔드로 api 넘어가서 DB에서 데이터를 찾아, 좋아요 +1 올려줌 apolloCashe를 백엔드에서 받아온 데이터 값으로 덮어씌운다. Scraping, Crawling Scrap…","frontmatter":{"date":"August 26, 2022","title":"Optimistic UI","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_9/"}},"next":{"id":"0786dbcf-d3c8-56cf-b5dc-774ad84d8acb","html":"<h3 id=\"정규표현식이란\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D%EC%9D%B4%EB%9E%80\" aria-label=\"정규표현식이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정규표현식이란?</h3>\n<ol>\n<li>\n<p>일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어이다.</p>\n</li>\n<li>\n<p>정규 표현식은 문자열을 대상으로 <strong>패턴 매칭 기능</strong>을 제공한다. 패턴 매칭 기능이란 특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환할 수 있는 기능을 말한다.</p>\n</li>\n</ol>\n<p>예를 들어, 회원가입 폼에서 사용자로부터 입력받은 핸드폰 번호가 유효한 전화번호인지 체크하는 경우를 생각해 보자. 핸드폰 번호는 “숫자 3개 + ‘-’ + 숫자 4개 + ‘-’ + 숫자 4개”라는 일정한 패턴이 있다. 이 핸드폰 번호 패턴을 다음과 같이 정규 표현식으로 정의하고, 사용자로부터 입력받은 문자열이 이 핸드폰 번호 패턴에 매칭하는지 체크할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 사용자로부터 입력받은 핸드폰 번호</span>\n<span class=\"token keyword\">const</span> phone <span class=\"token operator\">=</span> <span class=\"token string\">'010-1234-567팔'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 정규 표현식 리터럴로 핸드폰 번호 패턴을 정의</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^\\d{3}-\\d{4}-\\d{4}$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^\\d{3}-\\d{3,4}-\\d{4}$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// phone이 핸드폰 번호 패턴에 매칭하는지 테스트</span>\nregExp<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>phone<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code></pre></div>\n<h3 id=\"정규-표현식의-구성\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D%EC%9D%98-%EA%B5%AC%EC%84%B1\" aria-label=\"정규 표현식의 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정규 표현식의 구성</h3>\n<ol>\n<li>\n<p>정규 표현식 리터럴은 패턴과 플래그로 구성된다.</p>\n<ul>\n<li>pattern : 정규 표현식의 패턴</li>\n<li>flags: 정규 표현식의 플래그(g, i, m, u, y) >> 표 그리기</li>\n</ul>\n</li>\n<li>\n<p>RegExp 메서드</p>\n<ul>\n<li><strong>RegExp.prototype.exec</strong></li>\n</ul>\n<p>exec 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환한다. 매칭 결과가 없는 경우 null을 반환한다. exec 메서드는 g 플래그를 지정해도 첫번째 매칭 결과만 반환하므로 주의할 것 !</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token string\">'Is this all there is?'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">is</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">;</span>\n\nregExp<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ['is', index: 5, input: 'Is this all there is?', groups: undefined]</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token string\">'Is this all there is?'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">is</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">gi</span></span><span class=\"token punctuation\">;</span>\n\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regExp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ['Is', 'is', 'is']</span></code></pre></div>\n<ul>\n<li>\n<p><strong>RegExp.prototype.test</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">test 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 불리언 값으로반환한다.</code></pre></div>\n</li>\n<li>\n<p><strong>String.prototype.match</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">match 메서드는 대상 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 배열로 반환한다. exec 메서드와는 달리 match 메서드는 g 플래그가 지정되면 모든 매칭 결과를 배열로 반환한다.</code></pre></div>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token string\">'Is this all there is?'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">is</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">;</span>\n\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regExp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ['is', index: 5, input: 'Is this all there is?', groups: undefined]</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token string\">'Is this all there is?'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">is</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regExp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ['is', 'is']</span></code></pre></div>\n</li>\n</ol>\n<h3 id=\"패턴\" style=\"position:relative;\"><a href=\"#%ED%8C%A8%ED%84%B4\" aria-label=\"패턴 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>패턴</h3>\n<ul>\n<li>\n<p>임의의 문자열 검색\n.은 임의의 문자 한 개를 의미한다. 문자의 내용은 상관없다. 아래 코드를 보면 .을 3개 연속하여 패턴을 생성했으므로 문자의 내용과 상관없이 3자리 문자열과 매치한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token string\">'Is this all there is?'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">...</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regExp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ['Is ', 'thi', 's a', 'll ', 'the', 're ', 'is?']</span></code></pre></div>\n</li>\n<li>\n<p>반복 검색\n{m,n}은 앞의 패턴이(아래 코드의 경우 A)이 최소 m번, 최대 n번 반복되는 문자열을 의미한다. 콤마 뒤에 공백이 있으면 정상 동작하지 않으므로 주의!</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token string\">'A AA B BB Aa Bb AAA'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">A{1,2}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regExp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ['A', 'AA', 'A', 'AA', 'A']</span></code></pre></div>\n</li>\n</ul>","frontmatter":{"date":"August 26, 2022","title":"정규 표현식","categories":"RegExp","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_7/"}},"prev":{"id":"4fd2ea2e-2ebb-5022-bb76-0fe669f35b71","html":"<h3 id=\"var를-사용했을-때-문제점\" style=\"position:relative;\"><a href=\"#var%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%96%88%EC%9D%84-%EB%95%8C-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"var를 사용했을 때 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>var를 사용했을 때 문제점</h3>\n<ol>\n<li><strong>변수 중복 선언 허용</strong></li>\n<li><strong>함수 레벨 스코프</strong>\n<ol>\n<li>var로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 선언한 변수는 코드 블록 내에서 선언해도 전역 변수가 된다.</li>\n</ol>\n</li>\n<li><strong>변수 호이스팅</strong></li>\n</ol>\n<ul>\n<li>\n<p>var로 선언하면 변수 호이스팅에 의해 스코프의 선두로 끌어 올려진 것처럼 동작한다. 즉, 변수 선언문 이전에 참조할 수 있다. 단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfoo <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> foo<span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n<h3 id=\"var-let-const의-차이\" style=\"position:relative;\"><a href=\"#var-let-const%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"var let const의 차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>var, let, const의 차이</h3>\n<p>ES6에서 나온 let과 const 키워드는 위의 세 가지 문제점을 해결했다.</p>\n<h3 id=\"변수-중복-선언-불가\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EC%88%98-%EC%A4%91%EB%B3%B5-%EC%84%A0%EC%96%B8-%EB%B6%88%EA%B0%80\" aria-label=\"변수 중복 선언 불가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변수 중복 선언 불가</h3>\n<p>(1) let</p>\n<p>let 키워드로는 변수 중복 선언이 불가하지만, 재할당은 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'kmj'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// output: kmj</span>\n\n<span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'howdy'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// output: Uncaught SyntaxError: Identifier 'name' has already been declared</span>\n\nname <span class=\"token operator\">=</span> <span class=\"token string\">'howdy'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// output: howdy</span></code></pre></div>\n<p>(2) const</p>\n<p>const가 let과 다른 점이 있다면, 반드시 선언과 초기화를 동시에 진행되어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> name<span class=\"token punctuation\">;</span> <span class=\"token comment\">// output: Uncaught SyntaxError: Missing initializer in const declaration</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'kmj'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>const도 let과 마찬가지로 재선언이 불가하며, 더 나아가 재할당도 불가하다. 재할당의 경우, 원시 값은 불가능하지만, 객체는 가능하다. const 키워드는 재할당을 금지할 뿐, ‘불변’을 의미하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 원시값의 재할당</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'kmj'</span><span class=\"token punctuation\">;</span>\nname <span class=\"token operator\">=</span> <span class=\"token string\">'howdy'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// output: Uncaught TypeError: Assignment to constant variable.</span>\n\n<span class=\"token comment\">// 객체의 재할당</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  eng<span class=\"token operator\">:</span> <span class=\"token string\">'kmj'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nname<span class=\"token punctuation\">.</span>eng <span class=\"token operator\">=</span> <span class=\"token string\">'howdy'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// output: { eng: \"howdy\" }</span></code></pre></div>","frontmatter":{"date":"August 26, 2022","title":"let, const, var","categories":"javascript","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_8/"}},"site":{"siteMetadata":{"siteUrl":"https://leedawnn.github.io","comments":{"utterances":{"repo":"leedawnn/leedawnn.github.io"}}}}},"pageContext":{"slug":"/codecamp_blog_9/","nextSlug":"/codecamp_blog_7/","prevSlug":"/codecamp_blog_8/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}