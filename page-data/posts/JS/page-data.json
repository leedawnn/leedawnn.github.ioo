{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/JS",
    "result": {"pageContext":{"currentCategory":"JS","categories":["All","회고","frontend","react","js","javascript","RegExp","ts","JS","fronted","tool","lecture","web","environment","style"],"edges":[{"node":{"id":"3ecb7941-dbb4-5d02-959b-dfd107a449e5","excerpt":"호이스팅이란? 변수, 함수가 선언되기 전에 변수명, 함수명을 알고있는 것 var, let, const 모두 호이스팅이 되지만, let과 const는 선언 전까지 변수에 접근이 불가합니다. 호이스팅이 되더라도 접근을 막는 방법 let과 const는 변수가 되기 전까지 TDZ에 들어있다. var은 선언과 동시에 undefined 할당받아서, 에러 처리를 하기 어렵다. 함수 선언식을 사용하면 안되는 이유 같은 함수를 중복 선언을 해도 에러가 뜨지 않고 잘 실행된다. 이것은 협업에 있어 정말 나쁘다.. 이런 일이 발생하지 않도록 함수 표현식을 사용하거나 화살표 함수를 사용하자!","fields":{"slug":"/codecamp_blog_2/"},"frontmatter":{"categories":"JS","title":"hosting","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_1/"}},"previous":{"fields":{"slug":"/codecamp_blog_3/"}}},{"node":{"id":"c981ea3d-9067-542f-8bda-fa3409635668","excerpt":"async와 await라는 특별한 문법을 사용하면 promise를 좀 더 편하게 사용할 수 있다. async, await는 매우 편리하고, 사용법도 어렵지 않다. async 는 function 앞에 위치한다. function 앞에 를 붙이면 해당 함수는 항상 promise를 반환한다. promise가 아닌 값을 반환하더라도 이행 상태의 promise(resolved promise)로 감싸 이행된 promise가 반환되도록 한다. 아래 예시의 함수를 호출하면 가 1인 이행 Promise가 반환된다. 가 붙은 함수는 반드시 promise를 반환하고, promise가 아닌 것은 promise로 감싸 반환한다. 또한 는 함수 안에서만 동작한다. 란 무엇인지 알아보자. await  문법은 아래와 같다. 자바스크립트는 키워드를 만나면 promise가 처리될 때까지 기다린다(정말 뜻 그대로 기다림). 결과는 그 이후 반환된다. 1초 후 실행되는 promise를 예시로 사용하여 가 어떻게 동작하…","fields":{"slug":"/codecamp_blog_1/"},"frontmatter":{"categories":"JS","title":"async, await","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp-2/"}},"previous":{"fields":{"slug":"/codecamp_blog_2/"}}},{"node":{"id":"143e6bcd-a91d-5e59-850a-a96ccc684b6e","excerpt":"데이터를 받아와 화면에 뿌려줄 때 자주 쓰이는 배열 메서드! 쓸 때마다 매번 헷갈려서 구글링을 한다..🥲 게다가 배열 메서드마다 성능이 다 다르기 때문에, 용도에 따라서 어떤 것이 더 편하기도 하다. 확실하게 개념도 파악할 겸 블로그에 정리해놓고 필요할 때마다 보려고한다! for 가장 빠르고 단순하다. 모든 자료형에서 사용할 수 있다. continue / break 사용 가능 forEach forEach는 각 배열 요소에 대해 한 번씩 callback 함수를 실행한다. map과 reduce와는 달리 undefined를 반환하기 때문에 메서드 체인의 중간에 사용할 수 없다. 위에서 본 for문은 실무에서 잘 쓰이지 않는다.(계산이 많이 필요한 서비스라면 얘기가 달라진다) 가독성이 별로 좋지 않기 때문이다. forEach는 for문보다 가독성이 좋고, 복잡한 객체를 처리하는데 있어서 유리하다. 하지만, forEach문은 구문 밖으로 return 값을 받지 못한다는 단점이 있다. for…","fields":{"slug":"/master-array-method/"},"frontmatter":{"categories":"JS","title":"자바스크립트 배열 메서드 마스터하기","date":"July 14, 2022"}},"next":{"fields":{"slug":"/about-atomic-pattern/"}},"previous":{"fields":{"slug":"/codecamp-1/"}}},{"node":{"id":"34bef439-be79-54a0-8aaa-72dc91291aaa","excerpt":"객체지향 프로그래밍? 함수형 프로그래밍? 모던 자바스크립트 deep dive 스터디를 하면서, 자바스크립트 세계는 모든 것이 객체로 이루어져있다는 것을 보고 객체지향 프로그래밍을 배워야하는 것인가, 하지만 요새는 함수형 프로그래밍이 대세라던데..? 라는 주제로 팀원들과 얘기를 나눈 적이 있다. 잘은 모르겠지만 함수형 프로그래밍을 배워야한다로 결론이 났던 것 같은데, 이 글에서 이유를 자세히 알아보자 🤓 왜 함수형 프로그래밍을 배워야하나?   재미 / 실시간성 라이브 방송, 실시간 댓글, 협업, 메신저 독창성 / 완성도 애니메이션, 무한 스크롤, 벽돌 더 많아져야하는 동시성 비동기 I/O, CSP, Actor, SMT … 대용량 / 정확성 / 병렬성 MapReduce, Clojure Reducers… 복잡도 / MSA / … 많아지고 세밀해지는 도구들 예전에는 하나의 프레임워크가 전체의 구현을 대신하고, 해당 서비스의 구체화되는 부분만 알려주면 그 프레임워크가 모든 것을 동작 시켰다…","fields":{"slug":"/functional-programming/"},"frontmatter":{"categories":"JS","title":"웹개발에서 함수형 프로그래밍이 대세다?","date":"April 15, 2022"}},"next":{"fields":{"slug":"/lecture-growth/"}},"previous":{"fields":{"slug":"/you-shouldnt-do-eject/"}}},{"node":{"id":"e94c82d1-4c13-5f60-a35e-a9f0249a49d5","excerpt":"개인적으로 element에 텍스트를 추가하고 싶을 때는 innerText를 사용하는 편이에요. 두 프로퍼티는 어떤 공통점과 차이점을 가지고 있는지 궁금해져서 정리해보려고 합니다 ! 공통점 🍯 둘 다 텍스트노드를 추가해요. 텍스트를 추가한다는 공통점이 있어요. 결과 역시 동일해요. 해당 element의 텍스트 값을 반환해요. 즉, 어떤 텍스트를 가지고 있는지 알 수 있어요. 차이점 👻 는 와  요소를 포함한 모든 요소의 콘텐츠를 가져옵니다. 반면 는 “사람이 읽을 수 있는” 요소만 처리해요. 즉, 는 모든 텍스트를 그대로 가져오지만, 는 불필요한 공백을 제거하고 텍스트로 반환하는 차이점이 있어요. textConent가 먼저 만들어졌고, 더 빨리 사용되었다고 해요. 이런 이유로 브라우저 호환성도 좀 더 높습니다. 또한 큰 차이는 아니지만 더 가볍다고 알려져 있어요. 예를 들어, 아래와 같은 태그가 있다고 가정해볼게요. 이 때, innerText와 textContent의 결과는 다릅니다…","fields":{"slug":"/about-innerText-textContent/"},"frontmatter":{"categories":"JS","title":"innerText vs textContent","date":"March 16, 2022"}},"next":{"fields":{"slug":"/whta-is-CRS-SSR/"}},"previous":{"fields":{"slug":"/what-is-BEM/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}