{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/frontend",
    "result": {"pageContext":{"currentCategory":"frontend","categories":["All","회고","frontend","react","js","javascript","RegExp","ts","JS","fronted","tool","lecture","web","environment","style"],"edges":[{"node":{"id":"5256e5d6-1a4c-58c4-b91b-47247ffa33e5","excerpt":"권한분기 웹사이트를 방문하면 로그인을 한사람과 안한사람이 볼 수 있는 페이지가 따로 존재하는 경우가 있다. 이는 권한분기가 이뤄진 것이다.\n로그인에 등급을 매기면, 운영자로 로그인 한 사람, 판매자로 로그인 한 사람, 거래처 사장님으로 로그인 한 사람 등 다양하게 권한을 분리할 수도 있다. 어떻게 권한분기를 할수 있을까? HOC(Higher Order Component) HOC는 상위에 있는 컴포넌트로 다른 컴포넌트보다 먼저 실행되는 컴포넌트이다. 이렇게 권한을 체크하는 Hoc를 만들어주고 필요한 컴포넌트에 withAuth를 감싸서 export하면 해당 컴포넌트가 실행되기 이전에 권한체크 컴포넌트가 먼저 실행된다! HOF (Higher-Order Functioin) 고차함수(HOF)는 함수를 인수로 전달받거나 함수를 반환하는 함수이다.\n매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수로 반복되는 로직을 쉽게 재사용 할 수 있다.","fields":{"slug":"/codecamp_blog_31/"},"frontmatter":{"categories":"frontend","title":"권한분기, HOC, HOF","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_29/"}},"previous":{"fields":{"slug":"/codecamp_grad/"}}},{"node":{"id":"48b83273-a42d-5323-a5fb-75b0f4303a92","excerpt":"태블릿의 열풍, 스마트폰의 각기 다른 해상도, 다양한 모바일 기기의 등장으로 웹의 콘텐츠들이 각기 다르게 배치되어야 할 필요성이 증가되었다. 가끔 스마트폰으로 웹 서핑을 하다보면 보기 불편하게 배치되어 있는 경우를 볼 수 있다. (내 웹사이트 처럼) 이러한 문제점 때문에 여러 버전으로 웹을 제작해야 하는 불편함이 생겼다. 그러나 반응형 웹은 여러 버전 제작의 불편함을 해소한다. 반응형 웹은 UI를 의도대로 보여주면서 동시에 디스플레이되는 기기의 요구사항에 유연하게 반응할 수 있는 웹 디자인을 의미하며, 프론트엔드 개발자의 입장에서는 필수적으로 알아야만한다. 모바일 퍼스트 (Mobile First) 모바일 우선주의로 번역되기도 하는 모바일 퍼스트는 반응형 웹과 관련이 있는 개념이다. 번역한 그대로 웹을 제작할 때 모바일 기기를 우선으로 생각하여 디자인하고 개발하는 방식이다. LukeW에 의해 시작된? 개념이라고 한다. 아무래도 모바일 기기의 발달로 인해 데스크탑보다는 모바일 사용자가…","fields":{"slug":"/codecamp_blog_29/"},"frontmatter":{"categories":"frontend","title":"반응형이란?","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_28/"}},"previous":{"fields":{"slug":"/codecamp_blog_31/"}}},{"node":{"id":"51c0f565-c049-582b-82db-64fb25c600ab","excerpt":"구조 분해 할당 구조 분해 할당 구문은 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식이다. 객체 및 배열 리터럴 표현식을 사용하면 즉석에서 쉽게 데이터 뭉치를 만들 수 있다. 구조 분해 할당의 구문은 위와 비슷하지만, 대신 할당문의 좌변에서 사용하여, 원래 변수에서 어떤 값을 분해해 할당할지 정의한다. 구조 분해 할당은 Perl이나 Python 등 다른 언어가 가지고 있는 기능이다.","fields":{"slug":"/codecamp_blog_28/"},"frontmatter":{"categories":"frontend","title":"구조분해할당과 친해지기시도","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_27/"}},"previous":{"fields":{"slug":"/codecamp_blog_29/"}}},{"node":{"id":"2023ebcf-8c1b-59e9-b9b3-05d4b75b377e","excerpt":"Callback 콜백이란? 함수가 끝나고 난 뒤에 실행되는 함수. 자바스크립트에서 함수는 객체이다. 따라서 함수는 함수를 인자로 받고 다른 함수를 통해 반환될 수 있다. 인자로 대입되는 함수를 콜백함수라고 부른다. 왜? 자바스크립트는 이벤트 중심의 언어이다. 즉, 자바스크립트는 이벤트의 값이 반환될 때까지 기다리지 않고 다음의 이벤트를 계속 실행한다. 따라서 비동기적인 함수를 실행할 경우, 대표적으로 API 요청 등에서 특별한 처리를 해주지 않으면 함수를 원하는대로 실행하기 어렵다. 콜백이란 이러한 상황처럼 다른 코드가 특정코드가 마무리되기 전에 실행되지 않도록, 즉 비동기처리를 위한 방법이다.","fields":{"slug":"/codecamp_blog_27/"},"frontmatter":{"categories":"frontend","title":"콜백함수란?","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_24/"}},"previous":{"fields":{"slug":"/codecamp_blog_28/"}}},{"node":{"id":"93fec356-2fcc-5a4e-ac03-d9c3e3e99bc9","excerpt":"Domain 도메인은 인터넷에 연결된 컴퓨터의 ip를 사람이 쉽게 기억하기 어렵기 때문에 이를 위해서 각 ip에 사람이 쉽게 기억하고 입력할 수 있도록 문자(영문, 한글 등)로 만든 인터넷 주소이다. 도메인은 3단계의 역트리 구조로 구성되어있다. 1단계인 최상위 도메인(TLD, Top-Level Domain)은 도메인의 목적, 종류, 국가를 나타낸다. 2단계인 차상위 도메인(SLD, Second-Level Domain)은 도메인 이름을 등록한 조직을 나타낸다. 3단계는 도메인 이름(Domain Nmae)이다. 우리가 임의로 정할 수 있는 이름이기 때문에 모두 다르다. DNS(Domain Name System) DNS(Domain Name System)는 범국제적 단위로 웹사이트의 IP 주소와 도메인 주소를 이어주는 환경/시스템이다. DNS 서버는 이런 IP 주소를 특정 도메인 주소와 같다는 기록을 저장해두고, 인터넷 사용자들이 도메인 주소를 검색했을 때 IP 주소로 연결되도록 한다…","fields":{"slug":"/codecamp_blog_24/"},"frontmatter":{"categories":"frontend","title":"Domain, DNS, Hosting","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_26/"}},"previous":{"fields":{"slug":"/codecamp_blog_27/"}}},{"node":{"id":"a595163c-4a2a-517f-85cd-2306e7a06139","excerpt":"Token JSON Web Token, 줄여서 jwt는 서버에서 사용자를 식별할 수 있는 정보를 담아 클라이언트에 내려줄 때 쓰는 토큰이다.\n서버가 한 번 인증한 사용자에게 카드키를 준 거라고 생각하면 쉽다.\n토큰을 받은 클라이언트는 다음에 따로 인증을 하지 않아도 토큰을 이용해 로그인한 상태로 웹에 접근할 수 있다. 참고: https://jwt.io/ 빨간색 부분은 헤더로 어떤 알고리즘이 적용됐는지 등의 정보가 담겨 있다. 넘어가도 된다.\n핑크색 부분은 payload로 실제적인 객체 데이터가 담겨 있다. 토큰을 받고 나서 클라이언트가 서버에 무엇인가 요청을 할 때 인증이 필요한 요청이라면 토큰을 보내고 서버에서는 사용자를 확인할 수 있다. 또한 토큰이 암호화 되어 있으니 사용자의 생일과 같은 정보를 넣어도 좋고 토큰에 사용자에 관한 충분한 정보를 넣었다면 서버에 별도의 요청을 하지 않아도 된다.\n클라이언트에서 분홍색 부분을 디코드 하려면 jwt-decode 모듈을 쓰자. 하늘색 …","fields":{"slug":"/codecamp_blog_26/"},"frontmatter":{"categories":"frontend","title":"token, XSS, CSRF","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_25/"}},"previous":{"fields":{"slug":"/codecamp_blog_24/"}}},{"node":{"id":"771a4588-c92f-5b5f-b2a7-9e42e82d0add","excerpt":"재귀함수란 함수의 호출결과로 함수를 리턴하는 함수를 말한다. 알고리즘뿐만 아니라 여러가지로 많이 쓰이는 기법이다. 간단한 예를 들어보자. 보통 코드는 위에서 아래로 읽히지만(본인도 무조건 위에서 아래로 읽힌다고 생각하고 있었어서 재귀함수가 돌아가는 순서가 매우 헷갈렸었다.) 함수 안에서 함수를 선언해주기 때문에 선언은 단순히 선언으로만 끝나고, 마지막 리턴문(겸 재귀함수의 호출문) 에서 함수가 호출되 다시 처음으로 돌아가는 구조를 갖고있다. 재귀함수를 사용하는 대표적인 예로 피보나치수열이 있는데, 피보나치수열이란 1 번째항은 1, 2번째항은1, 3번째 항부터는 전전항과 전항을 더한 숫자로 구성되는 수열이다. 코드로는 아래와 같다. 하지만 재귀함수는 메모리를 많이 차지하고 성능이 반복문에 비해 느리다는 단점이 있다.(계속해서 함수를 호출하므로 스택의 메모리가 커진다.) 그러므로 사용해야 할 시점을 명확히 알고 사용하도록 하자.","fields":{"slug":"/codecamp_blog_25/"},"frontmatter":{"categories":"frontend","title":"재귀함수 찍먹하기","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_23/"}},"previous":{"fields":{"slug":"/codecamp_blog_26/"}}},{"node":{"id":"2f6db9ca-1d52-5925-9967-140550d2b1d1","excerpt":"CI (Continuous Integration)  CI는 Continuous Integration의 줄임말이다. 즉, 지속적인 통합이라는 의미! 지속적인 통합이란, 어플리케이션의 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어 공유 레포지토리에 통합히는 것을 의미한다. (가능하다면 하루에 여러번까지) CD (Continuous Delivery & Continuous Deployment) CD는 Continuous Delivery 혹은 Continuous Depolyment 두 용어 모두의 축약어이다. 해석하자면, 지속적인 서비스 제공 혹은 지속적인 배포라는 의미! Continuous Delivery는 공유 레포지토리로 자동으로 Release 하는 것,Continuous Deployment는 Production 레벨까지 자동으로 deploy 하는 것을 의미한다. 정리하자면, CI가 새로운 소스코드의 빌드, 테스트, 병합까지를 의미하였는데,CD는 개발자의 변경 사항이 레포지…","fields":{"slug":"/codecamp_blog_23/"},"frontmatter":{"categories":"frontend","title":"CI/CD","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_21/"}},"previous":{"fields":{"slug":"/codecamp_blog_25/"}}},{"node":{"id":"574422a8-cdcd-59b4-9e98-b9dfff7a32b9","excerpt":"HTTP HTTP는 Hyper Text Transfer Protocol의 줄임말으로써 서버와 클라이언트간에 데이터를 주고 받는 프로토콜입니다. HTTP는 텍스트, 이미지,영상, JSON 등등 거의 모든 형태의 데이터를 전송할 수 있다. 세상에 등장한지 벌써 30년이나 된 HTTP는 1997년 만들어진 HTTP/1.1가 가장 보편화 되어있으며, 현재는 HTTP/2를 거쳐 HTTP/3까지 개발된 상태입니다. TCP를 개선해서 만들어진 UDP가 HTTP/3 기술에 사용된다. HTTP는 보안적으로 안전한가? HTTP 통신은 클라이언트와 서버간의 통신에 있어서 별다른 보안 조치가 없기때문에 만약 누군가 네트워크 신호를 가로챈다면 HTTP의 내용은 그대로 외부에 노출된다. 중요 정보가 없는 소규모의 프로젝트라면 문제가 되지 않겠지만 고객의 개인정보나 비밀을 취급하는 대규모 서비스라면 큰 보안적 허점이 될 것이다. 이런 문제를 해결하기 위해 등장한 것이 HTTPS이다. HTTPS 요즘은 거의 …","fields":{"slug":"/codecamp_blog_21/"},"frontmatter":{"categories":"frontend","title":"https vs http","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_22/"}},"previous":{"fields":{"slug":"/codecamp_blog_23/"}}},{"node":{"id":"925bc7be-11a4-5866-8642-20b2220e0557","excerpt":"Docker 부팅 등 운영체제의 커널을 공유하는 가상머신. OS 전체를 다운받는 것이 아니라 훨씬 가볍고, 빠르다.\n또한, Node와 Mysql 등의 프로그램이 이미 설치된 Docker도 만들 수 있다. 개발 환경을 똑같이 세팅했다고 하더라도 운영체제에 따라서 달라지는 경우가 많다.\n따라서 운영체제에 상관없이 동일한 개발환경을 위해 를 사용한다. 세팅이 완료되어 있는 Dockerfile만 다운 받으면 끝남. Window나 Mac을 사용해도 리눅스로 통일되니까 충돌이 없음. 정리 개발/배포환경 통일 프로그램 미리 설치 가벼운 가상컴퓨터 Docker Image(이미지) 특정 프로세스를 실행하기 위한(즉, 컨테이너 생성(실행)에 필요한) 모든 파일과 설정값(환경)을 지닌 것으로, 더 이상의 의존성 파일을 컴파일하거나 이것저것 실치 할 필요 없는 상태의 파일. Docker-compose 여러 도커파일을 묶을 때 사용.","fields":{"slug":"/codecamp_blog_22/"},"frontmatter":{"categories":"frontend","title":"Docker","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_20/"}},"previous":{"fields":{"slug":"/codecamp_blog_21/"}}},{"node":{"id":"849b9339-0d0b-55f4-92da-db730f3b15ac","excerpt":"페이지네이션(pagination) 페이지네이션(pagination)은 여러 개의 게시물을 보여주는 웹사이트에서 보통 화면 하단에서 흔히 볼 수 있는 UI이다. 페이지네이션 알고리즘 꼭 React가 아니라도 어떤 프론트앤드 라이브러리를 사용하든 클라이언트 단에서 페이지네이션을 처리하려면 관련 알고리즘을 이해해두는 것이 좋다. 먼저 게시물을 여러 페이지에 나눠서 표시하려면 총 몇 개의 페이지가 필요한지를 알아야한다. 총 게시물 수를 페이지 당 표시할 게시물의 수로 나눈 뒤 올림을 하면 몇 개의 페이지가 필요한지를 계산할 수 있다. 예를 들어, 총 37개의 게시물이 있고, 페이지 당 10개의 게시물을 표시하려고 한다면, 37 / 10 = 3.7, 여기서 올림하여 결국 4개의 페이지가 필요하게 된다. (1~3 페이지에는 10개의 게시물이 표시되고, 4페이지에는 7개의 게시물이 표시가 되겠쥬?) 두번째로 알아야할 부분은 현재 페이지 번호를 기준으로 표시해줘야할 게시물들의 범위, 즉, 해당 …","fields":{"slug":"/codecamp_blog_20/"},"frontmatter":{"categories":"frontend","title":"Pagination vs Infinite Scroll","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_19/"}},"previous":{"fields":{"slug":"/codecamp_blog_22/"}}},{"node":{"id":"07b01823-a43f-5572-aa64-4049cf2c60e9","excerpt":"SPA(Single Page Application) 라고 한다. SPA에서는 서비스에 처음 접속할 때 모든 페이지의 데이터를 다 받아온다. 그려져있는 해당 페이지를 브라우저에 렌더링한다(re-rendering). ex) React 백엔드에서 받아오는 게 아니라 그려져 있는 페이지를 이동시키면서 화면에 띄워줌. SPA의 경우 최초 로딩에는 시간이 다소 걸릴 수 있으나 페이지를 이동할 때 걸리는 시간이 MPA에 비하여 압도적으로 짧다. 👍 SPA 장점 자연스러운 사용자 경험 (UX) 전체 페이지를 업데이트 할 필요가 없기 때문에 빠르고 ‘깜빡’ 거림이 없다. 필요한 리소스만 부분적으로 로딩 (성능) SPA의 Application은 서버에게 정적리소스를 한 번만 요청한다. 그리고 받은 데이터는 전부 저장해놓는다. (캐시=Cache) 서버의 템플릿 연산을 클라이언트로 분산 (성능) 컴포넌트별 개발 용이 (생산성) 모바일 앱 개발을 염두에 둔다면 동일한 API를 사용하도록 설계 가능 (생산…","fields":{"slug":"/codecamp_blog_13/"},"frontmatter":{"categories":"frontend","title":"SPA vs MPA","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_14/"}},"previous":{"fields":{"slug":"/codecamp_blog_16/"}}},{"node":{"id":"96e7f4e9-2d4c-5ae5-998d-5afd99a0b109","excerpt":"React에서는 전역상태를 관리하는 라이브러리들이 상당히 존재한다. 상태관리 라이브러리 중 바이블(?)이라고 불리는 Redux가 존재한다.(현재는 Redux toolkit을 사용하길 권장함) 이 Redux를 포함하여 많은 상태관리 라이브러리가 존재하는데, 하나씩 알아보도록 하자. 전역상태에 대한 정의 상태관리 라이러리를 소개하기 전, 먼저 에 대해 얘기해보자. 우리가 다루어야할 상태가 무엇이 있는지를 정의하고 이를 구분할 수 있어야 함. 어떤 상태가 들어가야하는지 기획을 생각하고 파악해볼 필요가 있음. 상태를 나눌 필요가 없다면? 굳이 상태관련 라이브러리를 사용해야 하는가? 글로벌 상태 관리란? 전역 상태관리를 사용하면 여러 구성 요소간에 데이터를 쉽게 전달/조작할 수 있습니다. (영구 전달 체인 끊기) 옵션비교 Context API Contex API는 React 16.3버전에서 출시된 옵션이다. 컨텍스트 API는 구성 요소 트리에서 쉽게 전달할 수 있는 전역 데이터를 생성한다.…","fields":{"slug":"/codecamp_blog_14/"},"frontmatter":{"categories":"frontend","title":"React 상태관리","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_15/"}},"previous":{"fields":{"slug":"/codecamp_blog_13/"}}},{"node":{"id":"81024205-7b63-5daf-90e4-5b9b1659a28c","excerpt":"React의 생명주기 (Life Cycle)이란 React 컴포넌트는 생명주기 즉 life cycle이란게 있는데, 이건 컴포넌트나 실행되거나 업데이트 혹은 제거될때 특정한 이벤트들이 발생한다. Mount 컴포넌트가 처음 실행될 때 그것을 Mount라고 표현한다. 컴포넌트가 시작되면 우선 context, defaultProps와 state를 저장한다. 그 후에 componentWillMount 메소드를 호출한다. 그리고 render로 컴포넌트를 DOM에 부착한 후 Mount가 완료된 후 componentDidMount가 호출된다. 주의할 점은, componentWillMount에서는 props나 state를 바꾸면 안된다. Mount 중이기 때문임. 그리고 아직 DOM에 render하지 않았기 때문에 DOM에도 접근할 수 없다. componentDidMount에서는 DOM에 접근할 수 있다. 그래서 여기에서는 주로 AJAX 요청을 하거나, setTimeout, setInterval…","fields":{"slug":"/codecamp_blog_15/"},"frontmatter":{"categories":"frontend","title":"State and Lifecycle","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_17/"}},"previous":{"fields":{"slug":"/codecamp_blog_14/"}}},{"node":{"id":"7353ce8c-7730-5411-a4eb-b847f5796613","excerpt":"Cookie 쿠키는 만료 기한이 있는 Key, Value 형태의 저장소이다. 장점: 대부분의 브라우저가 지원 단점 : 매 HTTP 요청마다 포함되어 api호출로 서버에 부담. 쿠키의 용량이 작음 (약 4KB) 암호화 존재 x => 사용자 정보 도난 위험 localStorage storage의 특징 문자열 데이터만 저장할 수 있다. 로컬 스토리지는 브라우저 창을 닫더라도 데이터 유지된다.(즉, 로그아웃을 하더라도 데어터 유지된다.) 장점: 서버에 불필요한 데이터를 저장해달라고 요청하지 않아도 된다. 용량이 크다 (5MB, 브라우저마다 차이 있음) 단점 :\n- HTML5를 지원하지 않는 브라우저의 경우 사용 불가 sessionStorage storage의 특징 문자열 데이터만 저장할수 있다. 세션 스토리지는 브라우저 창을 닫는 순간 영구적으로 데이터 삭제 장점: 서버에 불필요한 데이터를 저장해달라고 요청하지 않아도 된다. 용량이 크다 (5MB, 브라우저마다 차이 있음) 단점 :\n- H…","fields":{"slug":"/codecamp_blog_12/"},"frontmatter":{"categories":"frontend","title":"쿠키 vs 로컬 스토리지 vs 세션 스토리지","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_11/"}},"previous":{"fields":{"slug":"/codecamp_blog_17/"}}},{"node":{"id":"1d26449b-9843-5d3a-9d83-af555567467a","excerpt":"LazyLoad 이미지가 많은 사이트에서 한번에 모든 이미지를 다운받는다면 매우 느려짐.\n따라서, 맨 위의 화면에 보이는 이미지만 로드 한 후 스크롤을 내리면서 이미지가 보여져야할 때마다 이미지를 로드하면 데이터의 낭비를 막을 수 있다. 그래서 어떻게 구현할 수 있을까? 웹 페이지 내 이미지는 2가지 방법으로 로드할 수 있다. <img> 태그를 이용한 일반적인 방법 첫번째로 이미지 로딩을 사전에 막는 방법이다. 일반적으로 <img> 태그를 이용해서 이미지를 로드하기 위해 브라우저는  속성을 이용한다. 따라서 브라우저는  속성을 가지면 무조건 이미지를 로드한다! 그러므로 이미지들의 로딩을 지연시키려면  속성 대신 다른 속성에다가 이미지 URL을 넣으면 된다. 아래와 같이 라는 속성에 이미지 URL을 지정하면, 브라우저는 src 속성이 비워져있다고 인식하고 해당 이미지를 로드하지 않는다. PreLoad 이미지를 사전에 미리 로드해놓고, 필요할 때 이미 다운로드된 이미지를 보여줌으로써 …","fields":{"slug":"/codecamp_blog_11/"},"frontmatter":{"categories":"frontend","title":"Lazyload, Preload","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_10/"}},"previous":{"fields":{"slug":"/codecamp_blog_12/"}}},{"node":{"id":"6cd52fba-d645-508a-b1ca-9649a89144ef","excerpt":"Optimistic-UI 낙관적 UI라고도 한다. 보통 mutation을 날리고 응답을 받을 때까지 기다려야한다. 하지만 그렇게 하지 않고 바로 사용자에게 UI가 보여지는 것처럼 속이는 것을 Optimistic UI라고 한다. 성공 확률이 99%인 요청에 적용 2. 혹시 실패하더라도, 큰 영향이 없는 요청에 적용한다.\n예를 들어, 결제에 달아놓으면 큰일남 ㅎ 게시판 좋아요 기능에 ****를 적용한다고 해보자. 브라우저에서 백엔드로 API를 요청한다. 브라우저에서 useQuery를 날리면 바로 백엔드로 가는 게 아니라 apolloCache를 먼저 확인한다. (cache-first가 default여서) 캐시값을 받아오는 걸 기다리지 않고 바로 화면에서 +1,, (Optimisic-UI) cache 확인하고 백엔드로 api 넘어가서 DB에서 데이터를 찾아, 좋아요 +1 올려줌 apolloCashe를 백엔드에서 받아온 데이터 값으로 덮어씌운다. Scraping, Crawling Scrap…","fields":{"slug":"/codecamp_blog_9/"},"frontmatter":{"categories":"frontend","title":"Optimistic UI","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_7/"}},"previous":{"fields":{"slug":"/codecamp_blog_8/"}}},{"node":{"id":"64a441c6-15e8-577b-8c61-0813430d5ca7","excerpt":"webpack이란? Webpack은 모듈 번들링이다. html 파일에 들어가는 자바스크립트 파일들을 하나의 자바스크립트 파일로 만들어주는 방식을 모듈 번들링이라고 한다. 쉽게 말하자면, 많은 자바스크립트 파일을 하나의 자바스크립트 파일로 만들어 주는 것을 Webpack이라고 한다. webpack은 왜 사용해야할까? 옛날에는 페이지마다 새로운 html을 요청해서 뿌려주는 방식이였다면, 요새는 SPA 하나의 html 페이지에 여러 개의 자바스크립트 파일들이 포함한다. 연관되어 있는 자바스크립트 파일들을 하나의 파일로 묶어줘서 관리하기 편하다. 또한 파일을 컴파일 할 때, 여러 모듈들의 파일을 읽어오는데 시간이 오래 걸리는데, 이러한 문제를 해결하기 위해 여러 파일을 하나의 파일로 번들링 해주고, 하나의 자바스크립트 파일로 만들어서 웹페이지 성능 최적화를 해준다. webpack-dev-server webpack-dev-server는 라이브 리로드 기능을 제공하는 개발용 서버다. 빌드를 …","fields":{"slug":"/codecamp_blog_4/"},"frontmatter":{"categories":"frontend","title":"webpack이란","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_3/"}},"previous":{"fields":{"slug":"/codecamp_blog_5/"}}},{"node":{"id":"f9161340-b2a1-530a-9b73-dafb9c77680c","excerpt":"브라우저의 렌더링 과정 브라우저는 HTML, CSS, Javascript, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM과 CSSOM를 생성하고 이들을 결합하여 렌더 트리를 생성한다. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행한다. 이 때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)를 게산하고 브라우저 화면에 HTML 요소를 페인팅한다. HTTP 1.1과 HTTP 2.0 HTTP는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜이다. 이 가운데 HTTP/1.1과 HTTP/2.0의 차이점을 알아보자. HTTP …","fields":{"slug":"/codecamp_blog_3/"},"frontmatter":{"categories":"frontend","title":"브라우저의 렌더링 과정","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_2/"}},"previous":{"fields":{"slug":"/codecamp_blog_4/"}}},{"node":{"id":"ae9f3dff-6b00-5d54-a988-6256258508c1","excerpt":"본론으로 들어가기 전 최근 FE 재남님이 라이브로 코딩하시는 걸 봤었는데, REST API보다 GraphQL이 편리한 이유에 대해서 설명하시는 걸 듣고 graphQL을 공부하고 싶어졌다. 공부하기 전에는 쿼리 언어라고 하길래 데이터베이스 관련이구나 하고 지나갔었는데,, 묘하게 반전.. 😬 이제 REST API보다 GraphQL을 쓰고 싶어진 이유에 대해 알아보자. graphQL이란? GraphQL은 Facebook이 만든 API에 대한 쿼리 언어이다. GraphQL은 API에 대한 쿼리 언어이며 기존 데이터로 이러한 쿼리를 수행하기 위한 런타임입니다. GraphQL은 API의 데이터에 대한 완전하고 이해하기 쉬운 설명을 제공하며, 고객에게 필요한 것이 무엇이며 그 이상의 것이 없는지 정확히 물어볼 수 있는 힘을 제공하며, 시간이 지남에 따라 API를 더 쉽게 개발할 수 있도록 하며, 강력한 개발자 도구를 지원합니다. graphQL은 어떠한 문제를 해결할 수 있나? 일단 GraphQ…","fields":{"slug":"/what-about-graphql/"},"frontmatter":{"categories":"frontend","title":"REST API보다 graphQL을 쓰고 싶은 이유","date":"May 16, 2022"}},"next":{"fields":{"slug":"/react-characteristic/"}},"previous":{"fields":{"slug":"/lecture-junior-loadmap/"}}},{"node":{"id":"0d4985e4-75d9-520c-9d73-c77719c5439b","excerpt":"React의 특징은 무엇일까 면접에서 빼놓을 수 없는 React 관련 질문들 중 React의 특징에 대해서 알아보자 😉 1. 컴포넌트 기반 설계 의미 단위로 컴포넌트 구성 재사용성과 유지보수성 증가 부모, 자식 관계를 가짐 2. Virtual DOM 일반적으로 우리가 자바스크립트를 이용하여 DOM을 변경할 때, 브라우저가 DOM을 재구축하고 화면을 그리는 과정을 거치게 된다. 하지만 잦은 DOM 변경은 웹 사이트의 성능 문제를 야기한다. 그래서 React는 virtual DOM(가상돔)을 하나 만들어두고, 변경되어야할 DOM 요소를 미리 virtual DOM에서 모두 변경해두고 이것을 DOM(찐)에서 동기화시키는 방식을 사용한다. 이런식으로 하게 되면 DOM을 직접 변경시킬 때 발생하는 비효율을 어느정도 해결할 수 있게 된다. 3. 높은 자유도 컴포넌트는 고립되어 있고, 독립적이며 재사용이 가능하다. 그렇기 때문에 unit test가 가능해진다. Unit text란, 유닛 테스트의…","fields":{"slug":"/react-characteristic/"},"frontmatter":{"categories":"frontend","title":"React의 특징","date":"May 15, 2022"}},"next":{"fields":{"slug":"/image-optimization/"}},"previous":{"fields":{"slug":"/what-about-graphql/"}}},{"node":{"id":"05c02b84-3ca2-596b-9ab0-e179853bef35","excerpt":"CRA를 쓰는 이유 페이스북에서 개발한 Create-React-App(CRA) 보일러 플레이트를 사용하면 간편하게 리액트로 웹 애플리케이션을 만들 수 있다. CRA는 개발 환경을 구성할 때 필요한 여러가지 라이브러리나 웹팩의 설정 없이 쉽게 프로젝트를 시작할 수 있다. CRA에 대한 장점을 정리해보자. One Dependency\none build dependency를 가진다. Webpack, babel, ESLint 등을 사용하지만 응집력 있는 큐레이션된 경험을 제공한다. No Configuration Required\n개발 환경을 위해 많은 것을 설정하지 않아도 된다. CRA는 프로젝트에 필요한 필수적인 설정(Configuration)을 대신 해준다. CRA는 Autoprefixer를 지원해준다. 즉, 일반적인 CSS코드 생성을 하게 되면 자동으로 -webkit-, -ms- 등을 자동으로 적용해준다. CRA를 이용하면 기존 기능을 개선하거나 새로운 기능을 추가했을 때 패키지 버전만…","fields":{"slug":"/you-shouldnt-do-eject/"},"frontmatter":{"categories":"frontend","title":"Create-React-App에서 eject를 하면 안되는 이유","date":"April 29, 2022"}},"next":{"fields":{"slug":"/functional-programming/"}},"previous":{"fields":{"slug":"/js-deep-dive-study/"}}},{"node":{"id":"9edb0306-4a3f-5fc1-a59d-da4955498907","excerpt":"💅 예쁘면 장땡 처음 개발 블로그를 만들 때는 velog를 이용했다. 마크다운을 지원해서 글쓰는 것도 편하고, 무엇보다 사이트가 깔끔하고 예뻤다. 태그를 달아 카테고리 별로 보기 쉽게 정리할 수도 있었다. 그치만.. 잔디밭을 심지 못한다는 단점이 있어서 Jeykll이나 Hexo를 이용하여 github blog를 만들기도 했다. 하지만 테마가 마음에 들지 않아 글을 쓰고 싶은 마음이 들지 않았다. 핑계인가..ㅎ 그렇게 github 파도타기를 하며 예쁜 테마를 찾던 중, zoomkoding-gatsby-blog 템플릿이 눈에 들어왔다.\n예.뻤.다. ✨ ✅ Gatsby의 장점 Jekyll은 Ruby 기반으로 만들어져 있고, Gatsby는 React 기반으로 만들어졌다.\n현재 React를 공부하고 있고, 앞으로도 React를 현업에서 많이 쓸 예정이기 때문에 Gatsby를 사용하는 것이 블로그 세팅이 더 쉬울 것이라는 판단을 했다. 또한 개발자들이 서로 다른 콘텐츠, API 및 서비스를 …","fields":{"slug":"/make-gatsby-starter-zoomkoding/"},"frontmatter":{"categories":"frontend","title":"Gatsby로 github blog 만들기","date":"January 06, 2022"}},"next":null,"previous":{"fields":{"slug":"/whta-is-CRS-SSR/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}