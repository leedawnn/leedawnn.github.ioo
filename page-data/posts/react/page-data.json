{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/react",
    "result": {"pageContext":{"currentCategory":"react","categories":["All","frontend","react","js","javascript","RegExp","ts","JS","회고","fronted","tool","lecture","web","environment","style"],"edges":[{"node":{"id":"08193368-0795-5e3c-ba56-6c25097013bc","excerpt":"형제 컴포넌트는 직접적으로 연결되어 있지 않아 직접 데이터 전달 불가 오직 부모 ↔ 자식 간에만 데이터 교환이 가능!  데이터를 생성하는 컴포넌트 → 부모 컴포넌트 → 데이터를 필요로 하는 컴포넌트 순으로 전달됨 자식 → 부모로 상향식 데이터 전달","fields":{"slug":"/codecamp_blog_19/"},"frontmatter":{"categories":"react","title":"react 상태 끌어올리기","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_18/"}},"previous":{"fields":{"slug":"/codecamp_blog_20/"}}},{"node":{"id":"54b5d1ee-b2e1-53af-b831-1cc50bdb5323","excerpt":"state 이전에 포스팅 한 state에 관한 내용\nstate란 리액트 컴포넌트에서 데이터를 담기 위한 상자와도 같다. setState 함수는 state의 객체에 대한 업데이트를 실행하는 함수이다. state라는 상자에 담긴 내용들은 state의 내용을 바꾸는 setState 함수가 끝나면\n변동사항이 화면에 반영된다. 아래에서 언급할 내용은\n위 링크의 포스팅에서 다룬 내용이지만 prev를 사용하는 이유와 직결되는 내용이기 때문에 한번더 언급하겠다. setState는 불필요한 렌더링을 방지하면서 성능을 향상시키기 위해\n즉시 함수를 수행하지 않도록 설계되었다. 이러한 작동방식은 비동기적으로 작동한다라고도 이야기 할 수 있다. 아래는 버튼을 클릭할 때마다 count의 갯수를 하나씩 증가시킨 후 화면에 출력하는 문이다. 여기서 버튼을 클릭할 때마다 count를 5개씩 증가시켜주기 위해\n아래와 같은 문으로 수정하여 실행하면 어떻게 될까? 의도와는 달리 count는 여전히 1씩 증가한다. 그…","fields":{"slug":"/codecamp_blog_18/"},"frontmatter":{"categories":"react","title":"state prev","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_16/"}},"previous":{"fields":{"slug":"/codecamp_blog_19/"}}},{"node":{"id":"88853279-3cc8-5ad6-9add-4d3dce781127","excerpt":"Memoization 부모/자식 컴포넌트를 만들어서 간단한 카운터를 만든다. 이 과정에서 어떻게 성능 최적화를 하는 것이 좋은지 알아보자. 를 이용하여 만들게 되면 아래와 같은 일이 발생한다. state(counter)가 바뀌면 해당 컴포넌트가 리렌더링 리렌더링 전의 변수가 초기화 됨(새로 만들어짐) 함수도 초기화 됨(새로 만들어짐) 자식도 리렌더링 됨 예를 들어, 부모 컴포넌트에 랜덤 값이 들어가는 변수가 있다고 해보자. 그럼 state가 변하면서 리렌더링이 일어날 때마다 랜덤 값도 초기화된다. 이렇게 불필요한 리렌더링이 일어나는 것을 막기 위해서 를 사용해보자. memo 자식 컴포넌트를 memo로 감싸주면 리렌더링을 막을 수 있다. 하지만 부모 컴포넌트에서 props를 넘겨주게 되면 자식 컴포넌트에 memo가 걸려있어도 리렌더링이 일어나게 된다. useMemo() 를 사용하면 의존성 배열에 넘겨준 값이 변경되었을 때만 메모이제이션된 값을 다시 계산한다. 재계산하는 함수가 아주 …","fields":{"slug":"/codecamp_blog_10/"},"frontmatter":{"categories":"react","title":"Memoization","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_8/"}},"previous":{"fields":{"slug":"/codecamp_blog_11/"}}},{"node":{"id":"a66972cb-699b-516b-9d0c-d2fc8f26e4b6","excerpt":"이런 부분을 화살표 함수를 사용해주면, bind() 필요없이 this 값은 렉시컬 this가 된다. (예측한대로) 컴포넌트 생명주기 그리기(render) 그리고 난 뒤(componentDidMount) 그리고 난 뒤 변경됐을 때(componentDidUpdate) 그리고 난 뒤 사라질 때(componentWillIUnmount) useEffect 위의 모든 내용은  하나로 줄일 수 있다! useEffect는 모든 렌더링이 끝나고 실행된다. 하나로 합칠 수도 있음! useEffect의 잘못된 사용 예제 추가 렌더링 발생(setState) 무한 루프 useEffect 내에서 setState를 사용하게 되면 불필요한 리렌더나 무한루프를 일으키게 되고 성능 면에서 비효율적이게 된다. useEffect 사용 시 주의사항 useEffect 안에서 setState의 사용 ⇒ 정말 필요한 경우가 아니라면 지양해야한다. 컴포넌트가 마운트된 이후에 setState를 적용하게 되면, state가 변경…","fields":{"slug":"/codecamp_blog_6/"},"frontmatter":{"categories":"react","title":"useEffect, useRef","date":"August 26, 2022"}},"next":{"fields":{"slug":"/codecamp_blog_5/"}},"previous":{"fields":{"slug":"/codecamp_blog_7/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}