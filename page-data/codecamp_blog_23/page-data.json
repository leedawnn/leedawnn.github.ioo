{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/codecamp_blog_23/",
    "result": {"data":{"cur":{"id":"2f6db9ca-1d52-5925-9967-140550d2b1d1","html":"<h3 id=\"ci-continuous-integration\" style=\"position:relative;\"><a href=\"#ci-continuous-integration\" aria-label=\"ci continuous integration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CI (Continuous Integration)</h3>\n<p><img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&#x26;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbGXdIT%2FbtqI9GkH3wP%2F5Qx2zLKYRxsYWLSoS6KH3K%2Fimg.png\" alt=\"\"></p>\n<p>CI는 <strong>Continuous Integration</strong>의 줄임말이다.</p>\n<p>즉, 지속적인 통합이라는 의미! 지속적인 통합이란, 어플리케이션의 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어 공유 레포지토리에 통합히는 것을 의미한다. (가능하다면 하루에 여러번까지)</p>\n<h3 id=\"cd-continuous-delivery--continuous-deployment\" style=\"position:relative;\"><a href=\"#cd-continuous-delivery--continuous-deployment\" aria-label=\"cd continuous delivery  continuous deployment permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CD (Continuous Delivery &#x26; Continuous Deployment)</h3>\n<p>CD는 Continuous Delivery 혹은 Continuous Depolyment 두 용어 모두의 축약어이다. 해석하자면, 지속적인 서비스 제공 혹은 지속적인 배포라는 의미!</p>\n<p>Continuous Delivery는 공유 레포지토리로 자동으로 Release 하는 것,Continuous Deployment는 Production 레벨까지 자동으로 deploy 하는 것을 의미한다. 정리하자면, CI가 새로운 소스코드의 빌드, 테스트, 병합까지를 의미하였는데,CD는 개발자의 변경 사항이 레포지토리를 넘어, 고객의 프로덕션(Production) 환경까지 릴리즈 되는 것을 의미한다.</p>\n<p>CI에서 예로 든 MSA와 같은 환경에서 Agile 방법론이 적용될 경우, 서비스의 사용자는 최대한 빠른 시간 내에 최신 버전의 Production을 제공받을 필요가 있다.이 때, 소프트웨어가 언제든지 신뢰 가능한 수준의 버전을 유지할 수 있도록 support 하는 것이 CD라고 할 수 있쥬.</p>\n<p>이는 서비스의 개발팀과 비즈니스팀(영업, CS팀 등) 간의 커뮤니케이션 부족 문제를 해결해 줌으로써, 배포에 이르기까지의 노력을 최소한으로 단축시켜 준다는 Benefit을 제공한다.</p>","excerpt":"CI (Continuous Integration)  CI는 Continuous Integration의 줄임말이다. 즉, 지속적인 통합이라는 의미! 지속적인 통합이란, 어플리케이션의 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어 공유 레포지토리에 통합히는 것을 의미한다. (가능하다면 하루에 여러번까지) CD (Continuous Delivery & Continuous Deployment) CD는 Continuous Delivery 혹은 Continuous Depolyment 두 용어 모두의 축약어이다. 해석하자면, 지속적인 서비스 제공 혹은 지속적인 배포라는 의미! Continuous Delivery는 공유 레포지토리로 자동으로 Release 하는 것,Continuous Deployment는 Production 레벨까지 자동으로 deploy 하는 것을 의미한다. 정리하자면, CI가 새로운 소스코드의 빌드, 테스트, 병합까지를 의미하였는데,CD는 개발자의 변경 사항이 레포지…","frontmatter":{"date":"August 26, 2022","title":"CI/CD","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_23/"}},"next":{"id":"574422a8-cdcd-59b4-9e98-b9dfff7a32b9","html":"<h3 id=\"http\" style=\"position:relative;\"><a href=\"#http\" aria-label=\"http permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP</h3>\n<p>HTTP는 Hyper Text Transfer Protocol의 줄임말으로써 서버와 클라이언트간에 데이터를 주고 받는 프로토콜입니다. HTTP는 텍스트, 이미지,영상, JSON 등등 거의 모든 형태의 데이터를 전송할 수 있다.</p>\n<p>세상에 등장한지 벌써 30년이나 된 HTTP는 1997년 만들어진 HTTP/1.1가 가장 보편화 되어있으며, 현재는 HTTP/2를 거쳐 HTTP/3까지 개발된 상태입니다. TCP를 개선해서 만들어진 UDP가 HTTP/3 기술에 사용된다.</p>\n<h3 id=\"http는-보안적으로-안전한가\" style=\"position:relative;\"><a href=\"#http%EB%8A%94-%EB%B3%B4%EC%95%88%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%95%88%EC%A0%84%ED%95%9C%EA%B0%80\" aria-label=\"http는 보안적으로 안전한가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP는 보안적으로 안전한가?</h3>\n<p>HTTP 통신은 클라이언트와 서버간의 통신에 있어서 별다른 보안 조치가 없기때문에 만약 누군가 네트워크 신호를 가로챈다면 HTTP의 내용은 그대로 외부에 노출된다. 중요 정보가 없는 소규모의 프로젝트라면 문제가 되지 않겠지만 고객의 개인정보나 비밀을 취급하는 대규모 서비스라면 큰 보안적 허점이 될 것이다. 이런 문제를 해결하기 위해 등장한 것이 HTTPS이다.</p>\n<h3 id=\"https\" style=\"position:relative;\"><a href=\"#https\" aria-label=\"https permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS</h3>\n<p>요즘은 거의 모든 사이트의 주소창에서 자물쇠 표시를 볼 수 있다. HTTPS가 적용되었다는걸 알려주는게 바로 자물쇠이다. HTTPS가 옛날부터 보편화되어있지는 않았다. 처음에는 전자상거래 등 고객의 중요 정보를 다루는 사이트 위주로 사용됨.</p>\n<p>그러다가 2014년 구글에서는 HTTP를 HTTPS로 변환하라고 권고하기 시작했다. 귀찮은 작업을 시킬때는 보상이 있어야겠쥬? 구글은 HTTPS를 적용하는 사이트들에게 SEO(검색 엔진 최적화)에 있어서 가산점을 주겠다고함. 사용자 정보의 안전성도 보장받고, 사용자들의 웹사이트 유입도 늘릴수 있으니 HTTPS로 변환할 이유는 충분했을 것.</p>\n<h3 id=\"https는-어떤-방식으로-보안-이슈를-해결하는가\" style=\"position:relative;\"><a href=\"#https%EB%8A%94-%EC%96%B4%EB%96%A4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EC%95%88-%EC%9D%B4%EC%8A%88%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"https는 어떤 방식으로 보안 이슈를 해결하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS는 어떤 방식으로 보안 이슈를 해결하는가?</h3>\n<p>기존의 HTTP 프로토콜은 전송계층의 TCP위에서 동작한다. 여기서 SSL(Secure Sockets Layer)이라는 보안계층이 전송계층 위에 올라감. HTTPS는 SSL 위에 HTTP를 얹어서 보안이 보장된 통신을 하는 프로토콜이다. 이 통신 방식을 SSL 암호화 통신 이라고도 한다. SSL 암호화 통신은 공개키 암호화 방식이라는 알고리즘을 통해 구현된다.</p>","frontmatter":{"date":"August 26, 2022","title":"https vs http","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_21/"}},"prev":{"id":"771a4588-c92f-5b5f-b2a7-9e42e82d0add","html":"<p>재귀함수란 함수의 호출결과로 함수를 리턴하는 함수를 말한다.</p>\n<p>알고리즘뿐만 아니라 여러가지로 많이 쓰이는 기법이다.</p>\n<p>간단한 예를 들어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">11</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\nsum <span class=\"token operator\">+=</span> i\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 55</span>\n위의 코드는 <span class=\"token number\">1</span>부터 <span class=\"token number\">10</span>까지의 합을 구하는 매우 간단한 <span class=\"token keyword\">for</span>문 이다<span class=\"token punctuation\">.</span>\n\n이를 재귀함수로 표현하면\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">return</span> <span class=\"token number\">1</span> <span class=\"token comment\">// 종료 조건</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">return</span> n <span class=\"token operator\">+</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 재귀함수</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>보통 코드는 위에서 아래로 읽히지만(본인도 무조건 위에서 아래로 읽힌다고 생각하고 있었어서 재귀함수가 돌아가는 순서가 매우 헷갈렸었다.)</p>\n<p>함수 안에서 함수를 선언해주기 때문에 선언은 단순히 선언으로만 끝나고, 마지막 리턴문(겸 재귀함수의 호출문) 에서 함수가 호출되 다시 처음으로 돌아가는 구조를 갖고있다.</p>\n<p>재귀함수를 사용하는 대표적인 예로 피보나치수열이 있는데, 피보나치수열이란 1 번째항은 1, 2번째항은1, 3번째 항부터는 전전항과 전항을 더한 숫자로 구성되는 수열이다. 코드로는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 피보나치 수열을 저장하는 배열</span>\n  <span class=\"token keyword\">const</span> answer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">100000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    answer<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> answer<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> answer<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> answer<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>하지만 재귀함수는 메모리를 많이 차지하고 성능이 반복문에 비해 느리다는 단점이 있다.(계속해서 함수를 호출하므로 스택의 메모리가 커진다.)</p>\n<p>그러므로 사용해야 할 시점을 명확히 알고 사용하도록 하자.</p>","frontmatter":{"date":"August 26, 2022","title":"재귀함수 찍먹하기","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_25/"}},"site":{"siteMetadata":{"siteUrl":"https://leedawnn.github.io","comments":{"utterances":{"repo":"leedawnn/leedawnn.github.io"}}}}},"pageContext":{"slug":"/codecamp_blog_23/","nextSlug":"/codecamp_blog_21/","prevSlug":"/codecamp_blog_25/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}