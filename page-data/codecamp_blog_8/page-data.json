{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/codecamp_blog_8/",
    "result": {"data":{"cur":{"id":"4fd2ea2e-2ebb-5022-bb76-0fe669f35b71","html":"<h3 id=\"var를-사용했을-때-문제점\" style=\"position:relative;\"><a href=\"#var%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%96%88%EC%9D%84-%EB%95%8C-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"var를 사용했을 때 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>var를 사용했을 때 문제점</h3>\n<ol>\n<li><strong>변수 중복 선언 허용</strong></li>\n<li><strong>함수 레벨 스코프</strong>\n<ol>\n<li>var로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 선언한 변수는 코드 블록 내에서 선언해도 전역 변수가 된다.</li>\n</ol>\n</li>\n<li><strong>변수 호이스팅</strong></li>\n</ol>\n<ul>\n<li>\n<p>var로 선언하면 변수 호이스팅에 의해 스코프의 선두로 끌어 올려진 것처럼 동작한다. 즉, 변수 선언문 이전에 참조할 수 있다. 단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfoo <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> foo<span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n<h3 id=\"var-let-const의-차이\" style=\"position:relative;\"><a href=\"#var-let-const%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"var let const의 차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>var, let, const의 차이</h3>\n<p>ES6에서 나온 let과 const 키워드는 위의 세 가지 문제점을 해결했다.</p>\n<h3 id=\"변수-중복-선언-불가\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EC%88%98-%EC%A4%91%EB%B3%B5-%EC%84%A0%EC%96%B8-%EB%B6%88%EA%B0%80\" aria-label=\"변수 중복 선언 불가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변수 중복 선언 불가</h3>\n<p>(1) let</p>\n<p>let 키워드로는 변수 중복 선언이 불가하지만, 재할당은 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'kmj'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// output: kmj</span>\n\n<span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'howdy'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// output: Uncaught SyntaxError: Identifier 'name' has already been declared</span>\n\nname <span class=\"token operator\">=</span> <span class=\"token string\">'howdy'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// output: howdy</span></code></pre></div>\n<p>(2) const</p>\n<p>const가 let과 다른 점이 있다면, 반드시 선언과 초기화를 동시에 진행되어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> name<span class=\"token punctuation\">;</span> <span class=\"token comment\">// output: Uncaught SyntaxError: Missing initializer in const declaration</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'kmj'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>const도 let과 마찬가지로 재선언이 불가하며, 더 나아가 재할당도 불가하다. 재할당의 경우, 원시 값은 불가능하지만, 객체는 가능하다. const 키워드는 재할당을 금지할 뿐, ‘불변’을 의미하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 원시값의 재할당</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'kmj'</span><span class=\"token punctuation\">;</span>\nname <span class=\"token operator\">=</span> <span class=\"token string\">'howdy'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// output: Uncaught TypeError: Assignment to constant variable.</span>\n\n<span class=\"token comment\">// 객체의 재할당</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  eng<span class=\"token operator\">:</span> <span class=\"token string\">'kmj'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nname<span class=\"token punctuation\">.</span>eng <span class=\"token operator\">=</span> <span class=\"token string\">'howdy'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// output: { eng: \"howdy\" }</span></code></pre></div>","excerpt":"var를 사용했을 때 문제점 변수 중복 선언 허용 함수 레벨 스코프 var로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 선언한 변수는 코드 블록 내에서 선언해도 전역 변수가 된다. 변수 호이스팅 var로 선언하면 변수 호이스팅에 의해 스코프의 선두로 끌어 올려진 것처럼 동작한다. 즉, 변수 선언문 이전에 참조할 수 있다. 단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다. var, let, const의 차이 ES6에서 나온 let과 const 키워드는 위의 세 가지 문제점을 해결했다. 변수 중복 선언 불가 (1) let let 키워드로는 변수 중복 선언이 불가하지만, 재할당은 가능하다. (2) const const가 let과 다른 점이 있다면, 반드시 선언과 초기화를 동시에 진행되어야 한다. const도 let과 마찬가지로 재선언이 불가하며, 더 나아가 재할당도 불가하다. 재할당의 경우, 원시 값은 불가능하지만, …","frontmatter":{"date":"August 26, 2022","title":"let, const, var","categories":"javascript","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_8/"}},"next":{"id":"6cd52fba-d645-508a-b1ca-9649a89144ef","html":"<h3 id=\"optimistic-ui\" style=\"position:relative;\"><a href=\"#optimistic-ui\" aria-label=\"optimistic ui permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optimistic-UI</h3>\n<p>낙관적 UI라고도 한다. 보통 mutation을 날리고 응답을 받을 때까지 기다려야한다. 하지만 그렇게 하지 않고 바로 사용자에게 UI가 보여지는 것처럼 속이는 것을 Optimistic UI라고 한다.</p>\n<ol>\n<li>성공 확률이 99%인 요청에 적용 2. 혹시 실패하더라도, 큰 영향이 없는 요청에 적용한다.\n예를 들어, 결제에 달아놓으면 큰일남 ㅎ</li>\n</ol>\n<p>게시판 좋아요 기능에 **<code class=\"language-text\">Optimistic-UI</code>**를 적용한다고 해보자.</p>\n<ol>\n<li>브라우저에서 백엔드로 API를 요청한다.</li>\n<li>브라우저에서 useQuery를 날리면 바로 백엔드로 가는 게 아니라 apolloCache를 먼저 확인한다. (cache-first가 default여서)</li>\n<li>캐시값을 받아오는 걸 기다리지 않고 바로 화면에서 +1,, (<strong>Optimisic-UI</strong>)</li>\n<li>cache 확인하고 백엔드로 api 넘어가서 DB에서 데이터를 찾아, 좋아요 +1 올려줌</li>\n<li>apolloCashe를 백엔드에서 받아온 데이터 값으로 덮어씌운다.</li>\n</ol>\n<h3 id=\"scraping-crawling\" style=\"position:relative;\"><a href=\"#scraping-crawling\" aria-label=\"scraping crawling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scraping, Crawling</h3>\n<ul>\n<li>Scraping : html 코드 긁어오기 (한번만)\n<a href=\"https://www.npmjs.com/package/cheerio\">cheerio</a></li>\n<li>Crawling : html 코드 긁어오기 (정기적으로)\n<a href=\"https://www.npmjs.com/package/puppeteer\">puppeteer</a></li>\n</ul>\n<p><strong>API 요청하는 방법(REST API endpoint)</strong></p>\n<ol>\n<li>브라우저(받은 reponse가 html이면 해석해서 렌더링하는 능력이 있음) - 얘도 GET 요청</li>\n<li>postman</li>\n<li>terminal curl ~</li>\n</ol>\n<p>스크랩핑을 할 때 <strong>브라우저</strong>에서는 <code class=\"language-text\">CORS 정책</code>때문에 막힐 수 있음.</p>\n<p><strong>CORS</strong></p>\n<ul>\n<li>모바일</li>\n<li>백엔드에서 우회해서 요청하는 방법(<strong>proxy server</strong>)</li>\n</ul>\n<h3 id=\"ssr이-필요한-상황\" style=\"position:relative;\"><a href=\"#ssr%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%83%81%ED%99%A9\" aria-label=\"ssr이 필요한 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSR이 필요한 상황</h3>\n<p>중고마켓에서는 각 상품에 대한 og를 하드코딩할 수가 없다.(동적 페이지)</p>\n<p>⇒ <code class=\"language-text\">**useQuery**</code>로 받아와야함. 하지만, 이렇게 만들면 초기 렌더링을 했을 때는 백엔드 요청을 하지 않기 때문에 메타태그가 비어있다.</p>\n<p>따라서, html을 브라우저에 보내주기 전에 먼저 프론트엔드 서버에서 로직을 실행할 수 있게 한다.(axios, useQuery, useMutation 등) ⇒ <code class=\"language-text\">**getServerSideProps()**</code></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/df65986a-e73f-4984-8b01-29acb0f95d70/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-18_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.14.50.png\" alt=\"스크린샷 2022-08-18 오후 1.14.50.png\"></p>\n<p>서버 사이드 렌더링이 필요한 이유 중 **검색 엔진 최적화(SEO)**가 가장 많이 언급된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useMutation<span class=\"token punctuation\">,</span>gql<span class=\"token punctuation\">,</span>useQuery <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"@apollo/client\"</span>\n\n<span class=\"token comment\">//좋아요 갯수 가지고 오는 api _ 게시글 조회 api에서 좋아요 갯수만 뽑아 옵니다.</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">FETCH_BOARD</span> <span class=\"token operator\">=</span> gql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n\tquery fetchBoard($boardId: ID!){\n\t\tfetchBoard(boardId: $boardId){\n\t\t\t_id\n\t\t\tlikeCount\n\t\t}\n\t}\n</span><span class=\"token template-punctuation string\">`</span></span>\n\n<span class=\"token comment\">//좋아요 카운트 올리는 api</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">LIKE_BOARD</span> <span class=\"token operator\">=</span> gql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n\tmutation likeBoard($boardId:ID!){\n\t\tlikeBoard(boardId:$boardId)\n\t}\n</span><span class=\"token template-punctuation string\">`</span></span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>likeBoard<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useMutation</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LIKE_BOARD</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useQuery</span><span class=\"token punctuation\">(</span><span class=\"token constant\">FETCH_BOARD</span><span class=\"token punctuation\">,</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"token punctuation\">{</span>variables <span class=\"token operator\">:</span><span class=\"token punctuation\">{</span>boardId <span class=\"token operator\">:</span> <span class=\"token string\">\"게시글 아이디 넣어주세요!\"</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onClickOptimisticUI</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">//likeBoard 뮤테이션 함수를 실행하겠습니다.</span>\n\t\t<span class=\"token function\">likeBoard</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n\t\t\tvariables <span class=\"token operator\">:</span><span class=\"token punctuation\">{</span>\n\t\t\t\tboardId <span class=\"token operator\">:</span> <span class=\"token string\">\"게시글 아이디 넣어주세요!\"</span>\n\t\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n\t\t<span class=\"token comment\">// 응답을 받고난 후 받아온 응답을 다시 fetch 해줍니다. -> 느리고 효율적이지 못합니다.(백엔드에 요청을 한번더 해야하고 받아올때 까지 기다려야 합니다.)</span>\n\t\t<span class=\"token comment\">//refetchQueries: [</span>\n\t\t<span class=\"token comment\">//\t{</span>\n\t\t<span class=\"token comment\">//\t\tquery: FETCH_BOARD,</span>\n\t\t<span class=\"token comment\">//\t\tvariables : {\tboardId : \"//게시글 아이디 넣어주세요!\" }</span>\n\t\t<span class=\"token comment\">//\t}</span>\n\t\t<span class=\"token comment\">// ]</span>\n\n\t\t<span class=\"token operator\">**</span><span class=\"token comment\">//옵티미스틱 UI -> 캐시를 바꾸고 캐시값을 받아오는걸 기다리지 않고 바로 바꿔줍니다.**</span>\n\t\t<span class=\"token operator\">**</span>optimisticResponse<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n\t\t\tlikeBoard <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>data<span class=\"token operator\">?.</span>fetchBoard<span class=\"token punctuation\">.</span>likeCount <span class=\"token operator\">||</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token operator\">**</span>\n\t\t<span class=\"token operator\">**</span><span class=\"token comment\">// apollo 캐시를 직접 수정을 할 수 있었습니다.(백엔드 캐시가 아닙니다.) -> 느리지만 효율적입니다. (백엔드에 요청은 안하지만, 받아올때까지 기다려줘야 합니다.)</span>\n\t\t\t<span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cache<span class=\"token punctuation\">,</span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token comment\">// 이전 시간에는 modify를 사용했지만, 오늘은 writeQuery를 사용해보겠습니다.</span>\n\t\t\t\tcache<span class=\"token punctuation\">.</span><span class=\"token function\">writeQuery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n\t\t\t\t\tquery <span class=\"token operator\">:</span> <span class=\"token constant\">FETCH_BOARD</span><span class=\"token punctuation\">,</span>\n\t\t\t\t\tvariables <span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>boardId<span class=\"token operator\">:</span><span class=\"token string\">'게시글 아이디 넣어주세요!'</span><span class=\"token punctuation\">}</span>\n\t\t\t\t\t<span class=\"token comment\">//어떻게 수정할 것인지는 아래에 적어줍니다.</span>\n\t\t\t\t\tdata<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t\t\tfetchBoard<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t\t\t\t_id <span class=\"token operator\">:</span> <span class=\"token string\">'게시글 아이디 넣어주세요!'</span><span class=\"token punctuation\">,</span>\n\t\t\t\t\t\t\t__typename <span class=\"token operator\">:</span> <span class=\"token string\">\"Board\"</span>\n\t\t\t\t\t\t\tlikeCount<span class=\"token operator\">:</span> data<span class=\"token operator\">?.</span>likeBoard\n\t\t\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">}</span><span class=\"token operator\">**</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>\n\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">옵티미스틱 UI</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">현재카운트(좋아요):</span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">.</span>fetchBoard<span class=\"token punctuation\">.</span>likeCount<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>onClickOptimisticUI<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">좋아요 올리기!!</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n\t<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"date":"August 26, 2022","title":"Optimistic UI","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_9/"}},"prev":{"id":"88853279-3cc8-5ad6-9add-4d3dce781127","html":"<h3 id=\"memoization\" style=\"position:relative;\"><a href=\"#memoization\" aria-label=\"memoization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memoization</h3>\n<p>부모/자식 컴포넌트를 만들어서 간단한 카운터를 만든다. 이 과정에서 어떻게 성능 최적화를 하는 것이 좋은지 알아보자.</p>\n<p><code class=\"language-text\">useState</code>를 이용하여 만들게 되면 아래와 같은 일이 발생한다.</p>\n<ol>\n<li>state(counter)가 바뀌면 해당 컴포넌트가 리렌더링</li>\n<li>리렌더링 전의 변수가 초기화 됨(새로 만들어짐)</li>\n<li>함수도 초기화 됨(새로 만들어짐)</li>\n<li>자식도 리렌더링 됨</li>\n</ol>\n<p>예를 들어, 부모 컴포넌트에 랜덤 값이 들어가는 변수가 있다고 해보자. 그럼 state가 변하면서 리렌더링이 일어날 때마다 랜덤 값도 초기화된다. 이렇게 불필요한 리렌더링이 일어나는 것을 막기 위해서 <code class=\"language-text\">**memo**</code>를 사용해보자.</p>\n<h3 id=\"memo\" style=\"position:relative;\"><a href=\"#memo\" aria-label=\"memo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>memo</h3>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> memo <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">MemoizationChildPage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'자식이 렌더링 됩니다.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">=======================================</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">저는 자식 컴포넌트 입니다!</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">=======================================</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token function\">memo</span><span class=\"token punctuation\">(</span>MemoizationChildPage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>자식 컴포넌트를 memo로 감싸주면 리렌더링을 막을 수 있다.</p>\n<p>하지만 부모 컴포넌트에서 props를 넘겨주게 되면 자식 컴포넌트에 memo가 걸려있어도 리렌더링이 일어나게 된다.</p>\n<h3 id=\"usememo\" style=\"position:relative;\"><a href=\"#usememo\" aria-label=\"usememo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMemo()</h3>\n<p><code class=\"language-text\">useMemo</code>를 사용하면 의존성 배열에 넘겨준 값이 변경되었을 때만 메모이제이션된 값을 다시 계산한다.</p>\n<p><strong>재계산하는 함수가 아주 간단하다면 성능상의 차이는 아주 미미하겠지만, 만약 재계산하는 로직이 복잡하다면 불필요하게 비싼 계산을 하는 것을 막을 수 있다.</strong>(공식문서에서도 useMemo에 넘겨주는 콜백 함수의 이름이 computeExpensiveValue()라고 되어있다.)</p>\n<p>즉, 비싼 계산이 아니라면 useMemo 사용을 권장하지 않는다.</p>\n<h3 id=\"usecallback\" style=\"position:relative;\"><a href=\"#usecallback\" aria-label=\"usecallback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useCallback()</h3>\n<p><strong>메모이제이션된 함수를 반환한다라는 문장이 핵심이다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> useMemo <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// useCallback()을 잘못 사용하고 있는 예제(</span>\n<span class=\"token keyword\">const</span> onClickCount <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위의 코드는 그냥 setCountState(countState + 1) 자체를 기억하고 있는 거라서, 평생 1이다.</p>\n<p>따라서, 이렇게 prev를 받아서 증가시켜주는 것이 좋다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> onClickCount <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prev</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> prev <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"date":"August 26, 2022","title":"Memoization","categories":"react","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_10/"}},"site":{"siteMetadata":{"siteUrl":"https://leedawnn.github.io","comments":{"utterances":{"repo":"leedawnn/leedawnn.github.io"}}}}},"pageContext":{"slug":"/codecamp_blog_8/","nextSlug":"/codecamp_blog_9/","prevSlug":"/codecamp_blog_10/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}