{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/codecamp_blog_2/",
    "result": {"data":{"cur":{"id":"3ecb7941-dbb4-5d02-959b-dfd107a449e5","html":"<h3 id=\"호이스팅이란\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4%EB%9E%80\" aria-label=\"호이스팅이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호이스팅이란?</h3>\n<ul>\n<li>변수, 함수가 선언되기 전에 변수명, 함수명을 알고있는 것</li>\n<li>var, let, const 모두 호이스팅이 되지만, let과 const는 선언 전까지 변수에 접근이 불가합니다.</li>\n</ul>\n<h3 id=\"호이스팅이-되더라도-접근을-막는-방법\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4-%EB%90%98%EB%8D%94%EB%9D%BC%EB%8F%84-%EC%A0%91%EA%B7%BC%EC%9D%84-%EB%A7%89%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"호이스팅이 되더라도 접근을 막는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호이스팅이 되더라도 접근을 막는 방법</h3>\n<ul>\n<li>let과 const는 변수가 되기 전까지 TDZ에 들어있다.</li>\n<li>var은 선언과 동시에 undefined 할당받아서, 에러 처리를 하기 어렵다.</li>\n</ul>\n<h3 id=\"함수-선언식을-사용하면-안되는-이유\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%EC%8B%9D%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"함수 선언식을 사용하면 안되는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 선언식을 사용하면 안되는 이유</h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">aaaa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'중복 선언'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">aaaa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'중복 선언'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">aaaa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'중복 선언'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">aaaa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'중복 선언'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">aaaa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'중복 선언'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">aaaa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 중복 선언</span></code></pre></div>\n<p>같은 함수를 중복 선언을 해도 에러가 뜨지 않고 잘 실행된다. 이것은 협업에 있어 정말 나쁘다.. 이런 일이 발생하지 않도록 함수 표현식을 사용하거나 화살표 함수를 사용하자!</p>","excerpt":"호이스팅이란? 변수, 함수가 선언되기 전에 변수명, 함수명을 알고있는 것 var, let, const 모두 호이스팅이 되지만, let과 const는 선언 전까지 변수에 접근이 불가합니다. 호이스팅이 되더라도 접근을 막는 방법 let과 const는 변수가 되기 전까지 TDZ에 들어있다. var은 선언과 동시에 undefined 할당받아서, 에러 처리를 하기 어렵다. 함수 선언식을 사용하면 안되는 이유 같은 함수를 중복 선언을 해도 에러가 뜨지 않고 잘 실행된다. 이것은 협업에 있어 정말 나쁘다.. 이런 일이 발생하지 않도록 함수 표현식을 사용하거나 화살표 함수를 사용하자!","frontmatter":{"date":"August 26, 2022","title":"hosting","categories":"JS","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_2/"}},"next":{"id":"c981ea3d-9067-542f-8bda-fa3409635668","html":"<p>async와 await라는 특별한 문법을 사용하면 promise를 좀 더 편하게 사용할 수 있다. async, await는 매우 편리하고, 사용법도 어렵지 않다.</p>\n<h3 id=\"async\" style=\"position:relative;\"><a href=\"#async\" aria-label=\"async permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>async</h3>\n<p><code class=\"language-text\">async</code>는 function 앞에 위치한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>function 앞에 <code class=\"language-text\">async</code>를 붙이면 해당 함수는 항상 promise를 반환한다. promise가 아닌 값을 반환하더라도 이행 상태의 promise(resolved promise)로 감싸 이행된 promise가 반환되도록 한다.</p>\n<p>아래 예시의 함수를 호출하면 <code class=\"language-text\">result</code>가 1인 이행 Promise가 반환된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>alert<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span></code></pre></div>\n<p><code class=\"language-text\">async</code>가 붙은 함수는 반드시 promise를 반환하고, promise가 아닌 것은 promise로 감싸 반환한다. 또한 <code class=\"language-text\">await</code>는 <code class=\"language-text\">async</code>함수 안에서만 동작한다.</p>\n<p><code class=\"language-text\">await</code>란 무엇인지 알아보자.</p>\n<h3 id=\"await\" style=\"position:relative;\"><a href=\"#await\" aria-label=\"await permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>await</h3>\n<p><code class=\"language-text\">await</code> 문법은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// await는 async 함수 안에서만 동작합니다.</span>\n<span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> promise<span class=\"token punctuation\">;</span></code></pre></div>\n<p>자바스크립트는 <code class=\"language-text\">await</code>키워드를 만나면 promise가 처리될 때까지 기다린다(정말 뜻 그대로 기다림). 결과는 그 이후 반환된다.</p>\n<p>1초 후 실행되는 promise를 예시로 사용하여 <code class=\"language-text\">await</code>가 어떻게 동작하는지 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'완료!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> promise<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 프라미스가 이행될 때까지 기다림 (*)</span>\n\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"완료!\"</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>함수를 호출하고, 함수 본문이 실행되는 도중에 (*)로 표시한 줄에서 실행이 잠시 ‘중단’되었다가 promise가 처리되면 실행이 재개된다. 이때 promise 객체의 result 값이 변수 result에 할당된다. 따라서 위 예시를 실행하면 1초 뒤에 ‘완료!’가 출력된다.</p>\n<p><code class=\"language-text\">await</code>는 말 그대로 promise가 처리될 때까지 함수 실행을 기다리게 만들며, promise가 처리되면 그 결과와 함께 실행이 재개되죠. promise가 처리되길 기다리는 동안엔 엔진이 다른 일(다른 스크립트를 실행, 이벤트 처리 등)을 할 수 있기 때문에, CPU 리소스가 낭비되지 않는다.</p>\n<p><code class=\"language-text\">await</code>는 <code class=\"language-text\">promise.then</code>보다 좀 더 세련되게 promise의 result 값을 얻을 수 있도록 해주는 문법이다. <code class=\"language-text\">promise.then</code>보다 가독성 좋고 쓰기도 쉽다.</p>\n<h3 id=\"유의할-점\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EC%9D%98%ED%95%A0-%EC%A0%90\" aria-label=\"유의할 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유의할 점</h3>\n<p>일반함수엔 <code class=\"language-text\">await</code>를 사용할 수 없다! <code class=\"language-text\">async</code>함수가 아닌데 <code class=\"language-text\">await</code>를 사용하면 문법 에러가 발생한다.</p>","frontmatter":{"date":"August 26, 2022","title":"async, await","categories":"JS","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_1/"}},"prev":{"id":"f9161340-b2a1-530a-9b73-dafb9c77680c","html":"<h3 id=\"브라우저의-렌더링-과정\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95\" aria-label=\"브라우저의 렌더링 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저의 렌더링 과정</h3>\n<ol>\n<li>브라우저는 HTML, CSS, Javascript, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.</li>\n<li>브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM과 CSSOM를 생성하고 이들을 결합하여 렌더 트리를 생성한다.</li>\n<li>브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행한다. 이 때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다.</li>\n<li>렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)를 게산하고 브라우저 화면에 HTML 요소를 페인팅한다.</li>\n</ol>\n<h3 id=\"http-11과-http-20\" style=\"position:relative;\"><a href=\"#http-11%EA%B3%BC-http-20\" aria-label=\"http 11과 http 20 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP 1.1과 HTTP 2.0</h3>\n<p>HTTP는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜이다. 이 가운데 HTTP/1.1과 HTTP/2.0의 차이점을 알아보자.</p>\n<ol>\n<li>\n<p>HTTP 1.1</p>\n<p>HTTP 1.1은 기본적으로 커넥션 당 하나의 요청과 응답만 처리한다. 즉, 여러 개의 요청을 한 번에 전송할 수 없고 응답 또한 마찬가지다. 따라서 HTML 문서 내에 포함된 여러개의 리소스 요청(css 파일을 로드하는 link 태그, 이미지 파일을 로드하는 img 태그, JS를 로드하는 script 태그 등)에 의한 리소스 요청이 개별적으로 전송되고 응답 또한 개별적으로 전송된다.</p>\n<p>HTTP 1.1은 리소스의 동시 전송이 불가능한 구조이므로 요청할 리소스의 개수에 비례하여 응답 시간도 증가하는 단점이 있다.</p>\n</li>\n<li>\n<p>HTTP 2.0</p>\n<p>HTTP 2.0은 커넥션 당 여러 개의 요청과 응답이 가능하다. 여러 리소스의 동시 전송도 가능하므로 HTTP 1.1에 비해 페이지 로드 속도가 약 50% 정도 빠르다고 알려져 있다.</p>\n</li>\n<li>\n<p>HTTP 3</p>\n<p>HTTP/1, HTTP/2와 다르게 HTTP/3는 UDP 기반으로 통신한다.</p>\n</li>\n</ol>","frontmatter":{"date":"August 26, 2022","title":"브라우저의 렌더링 과정","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_3/"}},"site":{"siteMetadata":{"siteUrl":"https://leedawnn.github.io","comments":{"utterances":{"repo":"leedawnn/leedawnn.github.io"}}}}},"pageContext":{"slug":"/codecamp_blog_2/","nextSlug":"/codecamp_blog_1/","prevSlug":"/codecamp_blog_3/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}