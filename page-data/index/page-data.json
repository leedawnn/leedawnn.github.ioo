{
    "componentChunkName": "component---src-pages-index-js",
    "path": "/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"efb6e4b1-0176-5316-bef8-c2bf70350db4","excerpt":"팀프로젝트 첫 주, 으쌰으쌰 🏇 팀원들이 정해지고, 간단한 OT이후 기획과 팀 전반적인 룰을 진행하기 위해 회의를 진행했다. 아이스브레이킹 겸 자기소개는 전 주에 미리하고, 기획에 대해 아이템 하나씩 생각해오기로 했음. 생각해온 기획 아이디어에 대해 한 명씩 설명하고, 투표를 진행했다. 2번의 투표 결과, 내가 생각해온 아이템인 댕더가 채택되었다 😉  나름 쟁쟁했음. 팀원별로 역할을 분담했는데, 난 발표자료 제작을 맡았다. 개발은 개발대로 진행되고, 마지막 주에 ppt 작업하는데 정말 죽을뻔.. 밤새서 완성했다..🤪 기획 이후 와이어프레임, 플로우 차트, 간단한 목업 작업을 했다. 하지만… 와이어프레임, 플로우 차트를 만들면서 나타나는 기획적 빵꾸… 😇 이 때는 반려동물 굿즈 관련 스토어까지 얘기가 나왔었는데, 프로젝트가 너무 무거워져 일정에 차질이 생길 것 같아서 덜어내기로 했다. 대신 후원하기 페이지를 넣기로 했음!(But,, 2주차 중간점검 때 까임)댕댕이를 위한 어플인만큼 …","frontmatter":{"categories":"회고","title":"코드캠프 수료 회고","date":"October 04, 2022"},"fields":{"slug":"/codecamp_grad/"}}},{"node":{"id":"5256e5d6-1a4c-58c4-b91b-47247ffa33e5","excerpt":"권한분기 웹사이트를 방문하면 로그인을 한사람과 안한사람이 볼 수 있는 페이지가 따로 존재하는 경우가 있다. 이는 권한분기가 이뤄진 것이다.\n로그인에 등급을 매기면, 운영자로 로그인 한 사람, 판매자로 로그인 한 사람, 거래처 사장님으로 로그인 한 사람 등 다양하게 권한을 분리할 수도 있다. 어떻게 권한분기를 할수 있을까? HOC(Higher Order Component) HOC는 상위에 있는 컴포넌트로 다른 컴포넌트보다 먼저 실행되는 컴포넌트이다. 이렇게 권한을 체크하는 Hoc를 만들어주고 필요한 컴포넌트에 withAuth를 감싸서 export하면 해당 컴포넌트가 실행되기 이전에 권한체크 컴포넌트가 먼저 실행된다! HOF (Higher-Order Functioin) 고차함수(HOF)는 함수를 인수로 전달받거나 함수를 반환하는 함수이다.\n매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수로 반복되는 로직을 쉽게 재사용 할 수 있다.","frontmatter":{"categories":"frontend","title":"권한분기, HOC, HOF","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_31/"}}},{"node":{"id":"48b83273-a42d-5323-a5fb-75b0f4303a92","excerpt":"태블릿의 열풍, 스마트폰의 각기 다른 해상도, 다양한 모바일 기기의 등장으로 웹의 콘텐츠들이 각기 다르게 배치되어야 할 필요성이 증가되었다. 가끔 스마트폰으로 웹 서핑을 하다보면 보기 불편하게 배치되어 있는 경우를 볼 수 있다. (내 웹사이트 처럼) 이러한 문제점 때문에 여러 버전으로 웹을 제작해야 하는 불편함이 생겼다. 그러나 반응형 웹은 여러 버전 제작의 불편함을 해소한다. 반응형 웹은 UI를 의도대로 보여주면서 동시에 디스플레이되는 기기의 요구사항에 유연하게 반응할 수 있는 웹 디자인을 의미하며, 프론트엔드 개발자의 입장에서는 필수적으로 알아야만한다. 모바일 퍼스트 (Mobile First) 모바일 우선주의로 번역되기도 하는 모바일 퍼스트는 반응형 웹과 관련이 있는 개념이다. 번역한 그대로 웹을 제작할 때 모바일 기기를 우선으로 생각하여 디자인하고 개발하는 방식이다. LukeW에 의해 시작된? 개념이라고 한다. 아무래도 모바일 기기의 발달로 인해 데스크탑보다는 모바일 사용자가…","frontmatter":{"categories":"frontend","title":"반응형이란?","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_29/"}}},{"node":{"id":"51c0f565-c049-582b-82db-64fb25c600ab","excerpt":"구조 분해 할당 구조 분해 할당 구문은 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식이다. 객체 및 배열 리터럴 표현식을 사용하면 즉석에서 쉽게 데이터 뭉치를 만들 수 있다. 구조 분해 할당의 구문은 위와 비슷하지만, 대신 할당문의 좌변에서 사용하여, 원래 변수에서 어떤 값을 분해해 할당할지 정의한다. 구조 분해 할당은 Perl이나 Python 등 다른 언어가 가지고 있는 기능이다.","frontmatter":{"categories":"frontend","title":"구조분해할당과 친해지기시도","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_28/"}}},{"node":{"id":"2023ebcf-8c1b-59e9-b9b3-05d4b75b377e","excerpt":"Callback 콜백이란? 함수가 끝나고 난 뒤에 실행되는 함수. 자바스크립트에서 함수는 객체이다. 따라서 함수는 함수를 인자로 받고 다른 함수를 통해 반환될 수 있다. 인자로 대입되는 함수를 콜백함수라고 부른다. 왜? 자바스크립트는 이벤트 중심의 언어이다. 즉, 자바스크립트는 이벤트의 값이 반환될 때까지 기다리지 않고 다음의 이벤트를 계속 실행한다. 따라서 비동기적인 함수를 실행할 경우, 대표적으로 API 요청 등에서 특별한 처리를 해주지 않으면 함수를 원하는대로 실행하기 어렵다. 콜백이란 이러한 상황처럼 다른 코드가 특정코드가 마무리되기 전에 실행되지 않도록, 즉 비동기처리를 위한 방법이다.","frontmatter":{"categories":"frontend","title":"콜백함수란?","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_27/"}}},{"node":{"id":"93fec356-2fcc-5a4e-ac03-d9c3e3e99bc9","excerpt":"Domain 도메인은 인터넷에 연결된 컴퓨터의 ip를 사람이 쉽게 기억하기 어렵기 때문에 이를 위해서 각 ip에 사람이 쉽게 기억하고 입력할 수 있도록 문자(영문, 한글 등)로 만든 인터넷 주소이다. 도메인은 3단계의 역트리 구조로 구성되어있다. 1단계인 최상위 도메인(TLD, Top-Level Domain)은 도메인의 목적, 종류, 국가를 나타낸다. 2단계인 차상위 도메인(SLD, Second-Level Domain)은 도메인 이름을 등록한 조직을 나타낸다. 3단계는 도메인 이름(Domain Nmae)이다. 우리가 임의로 정할 수 있는 이름이기 때문에 모두 다르다. DNS(Domain Name System) DNS(Domain Name System)는 범국제적 단위로 웹사이트의 IP 주소와 도메인 주소를 이어주는 환경/시스템이다. DNS 서버는 이런 IP 주소를 특정 도메인 주소와 같다는 기록을 저장해두고, 인터넷 사용자들이 도메인 주소를 검색했을 때 IP 주소로 연결되도록 한다…","frontmatter":{"categories":"frontend","title":"Domain, DNS, Hosting","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_24/"}}},{"node":{"id":"a595163c-4a2a-517f-85cd-2306e7a06139","excerpt":"Token JSON Web Token, 줄여서 jwt는 서버에서 사용자를 식별할 수 있는 정보를 담아 클라이언트에 내려줄 때 쓰는 토큰이다.\n서버가 한 번 인증한 사용자에게 카드키를 준 거라고 생각하면 쉽다.\n토큰을 받은 클라이언트는 다음에 따로 인증을 하지 않아도 토큰을 이용해 로그인한 상태로 웹에 접근할 수 있다. 참고: https://jwt.io/ 빨간색 부분은 헤더로 어떤 알고리즘이 적용됐는지 등의 정보가 담겨 있다. 넘어가도 된다.\n핑크색 부분은 payload로 실제적인 객체 데이터가 담겨 있다. 토큰을 받고 나서 클라이언트가 서버에 무엇인가 요청을 할 때 인증이 필요한 요청이라면 토큰을 보내고 서버에서는 사용자를 확인할 수 있다. 또한 토큰이 암호화 되어 있으니 사용자의 생일과 같은 정보를 넣어도 좋고 토큰에 사용자에 관한 충분한 정보를 넣었다면 서버에 별도의 요청을 하지 않아도 된다.\n클라이언트에서 분홍색 부분을 디코드 하려면 jwt-decode 모듈을 쓰자. 하늘색 …","frontmatter":{"categories":"frontend","title":"token, XSS, CSRF","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_26/"}}},{"node":{"id":"771a4588-c92f-5b5f-b2a7-9e42e82d0add","excerpt":"재귀함수란 함수의 호출결과로 함수를 리턴하는 함수를 말한다. 알고리즘뿐만 아니라 여러가지로 많이 쓰이는 기법이다. 간단한 예를 들어보자. 보통 코드는 위에서 아래로 읽히지만(본인도 무조건 위에서 아래로 읽힌다고 생각하고 있었어서 재귀함수가 돌아가는 순서가 매우 헷갈렸었다.) 함수 안에서 함수를 선언해주기 때문에 선언은 단순히 선언으로만 끝나고, 마지막 리턴문(겸 재귀함수의 호출문) 에서 함수가 호출되 다시 처음으로 돌아가는 구조를 갖고있다. 재귀함수를 사용하는 대표적인 예로 피보나치수열이 있는데, 피보나치수열이란 1 번째항은 1, 2번째항은1, 3번째 항부터는 전전항과 전항을 더한 숫자로 구성되는 수열이다. 코드로는 아래와 같다. 하지만 재귀함수는 메모리를 많이 차지하고 성능이 반복문에 비해 느리다는 단점이 있다.(계속해서 함수를 호출하므로 스택의 메모리가 커진다.) 그러므로 사용해야 할 시점을 명확히 알고 사용하도록 하자.","frontmatter":{"categories":"frontend","title":"재귀함수 찍먹하기","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_25/"}}},{"node":{"id":"2f6db9ca-1d52-5925-9967-140550d2b1d1","excerpt":"CI (Continuous Integration)  CI는 Continuous Integration의 줄임말이다. 즉, 지속적인 통합이라는 의미! 지속적인 통합이란, 어플리케이션의 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어 공유 레포지토리에 통합히는 것을 의미한다. (가능하다면 하루에 여러번까지) CD (Continuous Delivery & Continuous Deployment) CD는 Continuous Delivery 혹은 Continuous Depolyment 두 용어 모두의 축약어이다. 해석하자면, 지속적인 서비스 제공 혹은 지속적인 배포라는 의미! Continuous Delivery는 공유 레포지토리로 자동으로 Release 하는 것,Continuous Deployment는 Production 레벨까지 자동으로 deploy 하는 것을 의미한다. 정리하자면, CI가 새로운 소스코드의 빌드, 테스트, 병합까지를 의미하였는데,CD는 개발자의 변경 사항이 레포지…","frontmatter":{"categories":"frontend","title":"CI/CD","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_23/"}}},{"node":{"id":"574422a8-cdcd-59b4-9e98-b9dfff7a32b9","excerpt":"HTTP HTTP는 Hyper Text Transfer Protocol의 줄임말으로써 서버와 클라이언트간에 데이터를 주고 받는 프로토콜입니다. HTTP는 텍스트, 이미지,영상, JSON 등등 거의 모든 형태의 데이터를 전송할 수 있다. 세상에 등장한지 벌써 30년이나 된 HTTP는 1997년 만들어진 HTTP/1.1가 가장 보편화 되어있으며, 현재는 HTTP/2를 거쳐 HTTP/3까지 개발된 상태입니다. TCP를 개선해서 만들어진 UDP가 HTTP/3 기술에 사용된다. HTTP는 보안적으로 안전한가? HTTP 통신은 클라이언트와 서버간의 통신에 있어서 별다른 보안 조치가 없기때문에 만약 누군가 네트워크 신호를 가로챈다면 HTTP의 내용은 그대로 외부에 노출된다. 중요 정보가 없는 소규모의 프로젝트라면 문제가 되지 않겠지만 고객의 개인정보나 비밀을 취급하는 대규모 서비스라면 큰 보안적 허점이 될 것이다. 이런 문제를 해결하기 위해 등장한 것이 HTTPS이다. HTTPS 요즘은 거의 …","frontmatter":{"categories":"frontend","title":"https vs http","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_21/"}}},{"node":{"id":"925bc7be-11a4-5866-8642-20b2220e0557","excerpt":"Docker 부팅 등 운영체제의 커널을 공유하는 가상머신. OS 전체를 다운받는 것이 아니라 훨씬 가볍고, 빠르다.\n또한, Node와 Mysql 등의 프로그램이 이미 설치된 Docker도 만들 수 있다. 개발 환경을 똑같이 세팅했다고 하더라도 운영체제에 따라서 달라지는 경우가 많다.\n따라서 운영체제에 상관없이 동일한 개발환경을 위해 를 사용한다. 세팅이 완료되어 있는 Dockerfile만 다운 받으면 끝남. Window나 Mac을 사용해도 리눅스로 통일되니까 충돌이 없음. 정리 개발/배포환경 통일 프로그램 미리 설치 가벼운 가상컴퓨터 Docker Image(이미지) 특정 프로세스를 실행하기 위한(즉, 컨테이너 생성(실행)에 필요한) 모든 파일과 설정값(환경)을 지닌 것으로, 더 이상의 의존성 파일을 컴파일하거나 이것저것 실치 할 필요 없는 상태의 파일. Docker-compose 여러 도커파일을 묶을 때 사용.","frontmatter":{"categories":"frontend","title":"Docker","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_22/"}}},{"node":{"id":"849b9339-0d0b-55f4-92da-db730f3b15ac","excerpt":"페이지네이션(pagination) 페이지네이션(pagination)은 여러 개의 게시물을 보여주는 웹사이트에서 보통 화면 하단에서 흔히 볼 수 있는 UI이다. 페이지네이션 알고리즘 꼭 React가 아니라도 어떤 프론트앤드 라이브러리를 사용하든 클라이언트 단에서 페이지네이션을 처리하려면 관련 알고리즘을 이해해두는 것이 좋다. 먼저 게시물을 여러 페이지에 나눠서 표시하려면 총 몇 개의 페이지가 필요한지를 알아야한다. 총 게시물 수를 페이지 당 표시할 게시물의 수로 나눈 뒤 올림을 하면 몇 개의 페이지가 필요한지를 계산할 수 있다. 예를 들어, 총 37개의 게시물이 있고, 페이지 당 10개의 게시물을 표시하려고 한다면, 37 / 10 = 3.7, 여기서 올림하여 결국 4개의 페이지가 필요하게 된다. (1~3 페이지에는 10개의 게시물이 표시되고, 4페이지에는 7개의 게시물이 표시가 되겠쥬?) 두번째로 알아야할 부분은 현재 페이지 번호를 기준으로 표시해줘야할 게시물들의 범위, 즉, 해당 …","frontmatter":{"categories":"frontend","title":"Pagination vs Infinite Scroll","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_20/"}}},{"node":{"id":"08193368-0795-5e3c-ba56-6c25097013bc","excerpt":"형제 컴포넌트는 직접적으로 연결되어 있지 않아 직접 데이터 전달 불가 오직 부모 ↔ 자식 간에만 데이터 교환이 가능!  데이터를 생성하는 컴포넌트 → 부모 컴포넌트 → 데이터를 필요로 하는 컴포넌트 순으로 전달됨 자식 → 부모로 상향식 데이터 전달","frontmatter":{"categories":"react","title":"react 상태 끌어올리기","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_19/"}}},{"node":{"id":"54b5d1ee-b2e1-53af-b831-1cc50bdb5323","excerpt":"state 이전에 포스팅 한 state에 관한 내용\nstate란 리액트 컴포넌트에서 데이터를 담기 위한 상자와도 같다. setState 함수는 state의 객체에 대한 업데이트를 실행하는 함수이다. state라는 상자에 담긴 내용들은 state의 내용을 바꾸는 setState 함수가 끝나면\n변동사항이 화면에 반영된다. 아래에서 언급할 내용은\n위 링크의 포스팅에서 다룬 내용이지만 prev를 사용하는 이유와 직결되는 내용이기 때문에 한번더 언급하겠다. setState는 불필요한 렌더링을 방지하면서 성능을 향상시키기 위해\n즉시 함수를 수행하지 않도록 설계되었다. 이러한 작동방식은 비동기적으로 작동한다라고도 이야기 할 수 있다. 아래는 버튼을 클릭할 때마다 count의 갯수를 하나씩 증가시킨 후 화면에 출력하는 문이다. 여기서 버튼을 클릭할 때마다 count를 5개씩 증가시켜주기 위해\n아래와 같은 문으로 수정하여 실행하면 어떻게 될까? 의도와는 달리 count는 여전히 1씩 증가한다. 그…","frontmatter":{"categories":"react","title":"state prev","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_18/"}}},{"node":{"id":"953ed6f8-7042-5b17-a1ed-a013c5e08ae8","excerpt":"클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. 클로저를 이해하려면 자바스크립트가 어떻게 변수의 유효범위를 지정하는지(Lexical scoping)를 먼저 이해해야 한다. 렉시컬 스코프(Lexical Scope) 렉시컬 스코프란 중첩된 함수 그룹에서 내부 함수가 상위 범위의 변수 및 기타 리소스에 액세스 할 수 있음을 의미한다. 즉, 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정한다는 뜻이며, 가장 중요한 점은 함수를 어디서 호출하는 지가 아니라 어디에 선언하였는지에 따라 결정된다. 다른 말로, 정적 스코프(Static Scope)라고 부르기도 한다. 클로저(Closure) 이제 다음 예제를 보자 이 코드는 바로 전의 예제와 완전히 동일한 결과가 실행된다. 하지만 흥미로운 차이는 displayName()함수가 실행되기 전에 외부함수인 makeFunc()로부터 리턴되어 myFunc 변수에 저장된다는 것이다. 한 눈에 봐서는 이 코드가 여전히 작동하는 것이 직관적으로 보…","frontmatter":{"categories":"js","title":"closure","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_16/"}}},{"node":{"id":"07b01823-a43f-5572-aa64-4049cf2c60e9","excerpt":"SPA(Single Page Application) 라고 한다. SPA에서는 서비스에 처음 접속할 때 모든 페이지의 데이터를 다 받아온다. 그려져있는 해당 페이지를 브라우저에 렌더링한다(re-rendering). ex) React 백엔드에서 받아오는 게 아니라 그려져 있는 페이지를 이동시키면서 화면에 띄워줌. SPA의 경우 최초 로딩에는 시간이 다소 걸릴 수 있으나 페이지를 이동할 때 걸리는 시간이 MPA에 비하여 압도적으로 짧다. 👍 SPA 장점 자연스러운 사용자 경험 (UX) 전체 페이지를 업데이트 할 필요가 없기 때문에 빠르고 ‘깜빡’ 거림이 없다. 필요한 리소스만 부분적으로 로딩 (성능) SPA의 Application은 서버에게 정적리소스를 한 번만 요청한다. 그리고 받은 데이터는 전부 저장해놓는다. (캐시=Cache) 서버의 템플릿 연산을 클라이언트로 분산 (성능) 컴포넌트별 개발 용이 (생산성) 모바일 앱 개발을 염두에 둔다면 동일한 API를 사용하도록 설계 가능 (생산…","frontmatter":{"categories":"frontend","title":"SPA vs MPA","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_13/"}}},{"node":{"id":"96e7f4e9-2d4c-5ae5-998d-5afd99a0b109","excerpt":"React에서는 전역상태를 관리하는 라이브러리들이 상당히 존재한다. 상태관리 라이브러리 중 바이블(?)이라고 불리는 Redux가 존재한다.(현재는 Redux toolkit을 사용하길 권장함) 이 Redux를 포함하여 많은 상태관리 라이브러리가 존재하는데, 하나씩 알아보도록 하자. 전역상태에 대한 정의 상태관리 라이러리를 소개하기 전, 먼저 에 대해 얘기해보자. 우리가 다루어야할 상태가 무엇이 있는지를 정의하고 이를 구분할 수 있어야 함. 어떤 상태가 들어가야하는지 기획을 생각하고 파악해볼 필요가 있음. 상태를 나눌 필요가 없다면? 굳이 상태관련 라이브러리를 사용해야 하는가? 글로벌 상태 관리란? 전역 상태관리를 사용하면 여러 구성 요소간에 데이터를 쉽게 전달/조작할 수 있습니다. (영구 전달 체인 끊기) 옵션비교 Context API Contex API는 React 16.3버전에서 출시된 옵션이다. 컨텍스트 API는 구성 요소 트리에서 쉽게 전달할 수 있는 전역 데이터를 생성한다.…","frontmatter":{"categories":"frontend","title":"React 상태관리","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_14/"}}},{"node":{"id":"81024205-7b63-5daf-90e4-5b9b1659a28c","excerpt":"React의 생명주기 (Life Cycle)이란 React 컴포넌트는 생명주기 즉 life cycle이란게 있는데, 이건 컴포넌트나 실행되거나 업데이트 혹은 제거될때 특정한 이벤트들이 발생한다. Mount 컴포넌트가 처음 실행될 때 그것을 Mount라고 표현한다. 컴포넌트가 시작되면 우선 context, defaultProps와 state를 저장한다. 그 후에 componentWillMount 메소드를 호출한다. 그리고 render로 컴포넌트를 DOM에 부착한 후 Mount가 완료된 후 componentDidMount가 호출된다. 주의할 점은, componentWillMount에서는 props나 state를 바꾸면 안된다. Mount 중이기 때문임. 그리고 아직 DOM에 render하지 않았기 때문에 DOM에도 접근할 수 없다. componentDidMount에서는 DOM에 접근할 수 있다. 그래서 여기에서는 주로 AJAX 요청을 하거나, setTimeout, setInterval…","frontmatter":{"categories":"frontend","title":"State and Lifecycle","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_15/"}}},{"node":{"id":"8cc45da0-e85c-5757-aea5-94889be12746","excerpt":"순회(iteration) 순회에 필요한 메서드는 map.keys(), map.values(), map.entries() 등이 있다. 이 메서드들은 포괄적인 용도로 만들어졌기 때문에 메서드를 적용할 자료구조는 일련의 합의를 준수해야 한다. 커스텀 자료구조를 대상으로 순회를 해야 한다면 이 메서드들을 쓰지 못하고 직접 메서드를 구현해야 한다. keys(), values(), entries()를 사용할 수 있는 자료구조는 다음과 같다. Map Set Array 일반 객체에도 순회 관련 메서드가 있긴 한데, keys(), values(), entries()와는 문법에 차이가 있습니다. Object.keys, values, entries 일반 객체엔 다음과 같은 메서드를 사용할 수 있다. Object.keys(obj) – 객체의 키만 담은 배열을 반환. Object.values(obj) – 객체의 값만 담은 배열을 반환. Object.entries(obj) – [키, 값] 쌍을 담은 배열을…","frontmatter":{"categories":"js","title":"Object.keys, values, entries","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_17/"}}},{"node":{"id":"7353ce8c-7730-5411-a4eb-b847f5796613","excerpt":"Cookie 쿠키는 만료 기한이 있는 Key, Value 형태의 저장소이다. 장점: 대부분의 브라우저가 지원 단점 : 매 HTTP 요청마다 포함되어 api호출로 서버에 부담. 쿠키의 용량이 작음 (약 4KB) 암호화 존재 x => 사용자 정보 도난 위험 localStorage storage의 특징 문자열 데이터만 저장할 수 있다. 로컬 스토리지는 브라우저 창을 닫더라도 데이터 유지된다.(즉, 로그아웃을 하더라도 데어터 유지된다.) 장점: 서버에 불필요한 데이터를 저장해달라고 요청하지 않아도 된다. 용량이 크다 (5MB, 브라우저마다 차이 있음) 단점 :\n- HTML5를 지원하지 않는 브라우저의 경우 사용 불가 sessionStorage storage의 특징 문자열 데이터만 저장할수 있다. 세션 스토리지는 브라우저 창을 닫는 순간 영구적으로 데이터 삭제 장점: 서버에 불필요한 데이터를 저장해달라고 요청하지 않아도 된다. 용량이 크다 (5MB, 브라우저마다 차이 있음) 단점 :\n- H…","frontmatter":{"categories":"frontend","title":"쿠키 vs 로컬 스토리지 vs 세션 스토리지","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_12/"}}},{"node":{"id":"1d26449b-9843-5d3a-9d83-af555567467a","excerpt":"LazyLoad 이미지가 많은 사이트에서 한번에 모든 이미지를 다운받는다면 매우 느려짐.\n따라서, 맨 위의 화면에 보이는 이미지만 로드 한 후 스크롤을 내리면서 이미지가 보여져야할 때마다 이미지를 로드하면 데이터의 낭비를 막을 수 있다. 그래서 어떻게 구현할 수 있을까? 웹 페이지 내 이미지는 2가지 방법으로 로드할 수 있다. <img> 태그를 이용한 일반적인 방법 첫번째로 이미지 로딩을 사전에 막는 방법이다. 일반적으로 <img> 태그를 이용해서 이미지를 로드하기 위해 브라우저는  속성을 이용한다. 따라서 브라우저는  속성을 가지면 무조건 이미지를 로드한다! 그러므로 이미지들의 로딩을 지연시키려면  속성 대신 다른 속성에다가 이미지 URL을 넣으면 된다. 아래와 같이 라는 속성에 이미지 URL을 지정하면, 브라우저는 src 속성이 비워져있다고 인식하고 해당 이미지를 로드하지 않는다. PreLoad 이미지를 사전에 미리 로드해놓고, 필요할 때 이미 다운로드된 이미지를 보여줌으로써 …","frontmatter":{"categories":"frontend","title":"Lazyload, Preload","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_11/"}}},{"node":{"id":"88853279-3cc8-5ad6-9add-4d3dce781127","excerpt":"Memoization 부모/자식 컴포넌트를 만들어서 간단한 카운터를 만든다. 이 과정에서 어떻게 성능 최적화를 하는 것이 좋은지 알아보자. 를 이용하여 만들게 되면 아래와 같은 일이 발생한다. state(counter)가 바뀌면 해당 컴포넌트가 리렌더링 리렌더링 전의 변수가 초기화 됨(새로 만들어짐) 함수도 초기화 됨(새로 만들어짐) 자식도 리렌더링 됨 예를 들어, 부모 컴포넌트에 랜덤 값이 들어가는 변수가 있다고 해보자. 그럼 state가 변하면서 리렌더링이 일어날 때마다 랜덤 값도 초기화된다. 이렇게 불필요한 리렌더링이 일어나는 것을 막기 위해서 를 사용해보자. memo 자식 컴포넌트를 memo로 감싸주면 리렌더링을 막을 수 있다. 하지만 부모 컴포넌트에서 props를 넘겨주게 되면 자식 컴포넌트에 memo가 걸려있어도 리렌더링이 일어나게 된다. useMemo() 를 사용하면 의존성 배열에 넘겨준 값이 변경되었을 때만 메모이제이션된 값을 다시 계산한다. 재계산하는 함수가 아주 …","frontmatter":{"categories":"react","title":"Memoization","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_10/"}}},{"node":{"id":"4fd2ea2e-2ebb-5022-bb76-0fe669f35b71","excerpt":"var를 사용했을 때 문제점 변수 중복 선언 허용 함수 레벨 스코프 var로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 선언한 변수는 코드 블록 내에서 선언해도 전역 변수가 된다. 변수 호이스팅 var로 선언하면 변수 호이스팅에 의해 스코프의 선두로 끌어 올려진 것처럼 동작한다. 즉, 변수 선언문 이전에 참조할 수 있다. 단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다. var, let, const의 차이 ES6에서 나온 let과 const 키워드는 위의 세 가지 문제점을 해결했다. 변수 중복 선언 불가 (1) let let 키워드로는 변수 중복 선언이 불가하지만, 재할당은 가능하다. (2) const const가 let과 다른 점이 있다면, 반드시 선언과 초기화를 동시에 진행되어야 한다. const도 let과 마찬가지로 재선언이 불가하며, 더 나아가 재할당도 불가하다. 재할당의 경우, 원시 값은 불가능하지만, …","frontmatter":{"categories":"javascript","title":"let, const, var","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_8/"}}},{"node":{"id":"6cd52fba-d645-508a-b1ca-9649a89144ef","excerpt":"Optimistic-UI 낙관적 UI라고도 한다. 보통 mutation을 날리고 응답을 받을 때까지 기다려야한다. 하지만 그렇게 하지 않고 바로 사용자에게 UI가 보여지는 것처럼 속이는 것을 Optimistic UI라고 한다. 성공 확률이 99%인 요청에 적용 2. 혹시 실패하더라도, 큰 영향이 없는 요청에 적용한다.\n예를 들어, 결제에 달아놓으면 큰일남 ㅎ 게시판 좋아요 기능에 ****를 적용한다고 해보자. 브라우저에서 백엔드로 API를 요청한다. 브라우저에서 useQuery를 날리면 바로 백엔드로 가는 게 아니라 apolloCache를 먼저 확인한다. (cache-first가 default여서) 캐시값을 받아오는 걸 기다리지 않고 바로 화면에서 +1,, (Optimisic-UI) cache 확인하고 백엔드로 api 넘어가서 DB에서 데이터를 찾아, 좋아요 +1 올려줌 apolloCashe를 백엔드에서 받아온 데이터 값으로 덮어씌운다. Scraping, Crawling Scrap…","frontmatter":{"categories":"frontend","title":"Optimistic UI","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_9/"}}},{"node":{"id":"0786dbcf-d3c8-56cf-b5dc-774ad84d8acb","excerpt":"정규표현식이란? 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어이다. 정규 표현식은 문자열을 대상으로 패턴 매칭 기능을 제공한다. 패턴 매칭 기능이란 특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환할 수 있는 기능을 말한다. 예를 들어, 회원가입 폼에서 사용자로부터 입력받은 핸드폰 번호가 유효한 전화번호인지 체크하는 경우를 생각해 보자. 핸드폰 번호는 “숫자 3개 + ‘-’ + 숫자 4개 + ‘-’ + 숫자 4개”라는 일정한 패턴이 있다. 이 핸드폰 번호 패턴을 다음과 같이 정규 표현식으로 정의하고, 사용자로부터 입력받은 문자열이 이 핸드폰 번호 패턴에 매칭하는지 체크할 수 있다. 정규 표현식의 구성 정규 표현식 리터럴은 패턴과 플래그로 구성된다. pattern : 정규 표현식의 패턴 flags: 정규 표현식의 플래그(g, i, m, u, y) >> 표 그리기 RegExp 메서드 RegExp.prototype.exec exec 메서드는 인수로 전달받은…","frontmatter":{"categories":"RegExp","title":"정규 표현식","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_7/"}}},{"node":{"id":"a66972cb-699b-516b-9d0c-d2fc8f26e4b6","excerpt":"이런 부분을 화살표 함수를 사용해주면, bind() 필요없이 this 값은 렉시컬 this가 된다. (예측한대로) 컴포넌트 생명주기 그리기(render) 그리고 난 뒤(componentDidMount) 그리고 난 뒤 변경됐을 때(componentDidUpdate) 그리고 난 뒤 사라질 때(componentWillIUnmount) useEffect 위의 모든 내용은  하나로 줄일 수 있다! useEffect는 모든 렌더링이 끝나고 실행된다. 하나로 합칠 수도 있음! useEffect의 잘못된 사용 예제 추가 렌더링 발생(setState) 무한 루프 useEffect 내에서 setState를 사용하게 되면 불필요한 리렌더나 무한루프를 일으키게 되고 성능 면에서 비효율적이게 된다. useEffect 사용 시 주의사항 useEffect 안에서 setState의 사용 ⇒ 정말 필요한 경우가 아니라면 지양해야한다. 컴포넌트가 마운트된 이후에 setState를 적용하게 되면, state가 변경…","frontmatter":{"categories":"react","title":"useEffect, useRef","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_6/"}}},{"node":{"id":"e2b1e6ee-f1e6-5f95-b493-aa325413d35e","excerpt":"JavaScript와 TypeScript TypeScript는 JavaScript 기반의 언어 JavaScript는 클라이언트 측 스크립팅 언어 TypeScript는 객체 지향 컴파일 언어 객체 지향 프로그래밍 패러다임은 데이터 추상화에 중심 객체와 클래스라는 두 주요 개념을 기반으로 함 JavaScript 웹 개발에 주로 사용됨 웹 페이지를 대화식으로 만드는 프로그래밍 언어 폼 유효성 검사, 애니메이션 적용 및 이벤트 생성을 수행 클라이언트 측 스크립팅 언어 사용자가 웹 브라우저를 열고 웹 페이지를 요청하면 해당 요청이 웹 서버로 이동함 멀티 스레딩, 멀티 프로세싱 기능이 없음 TypeScript JavaScript의 상위 집합으로 JavaScript의 모든 기능이 있음 TypeScript 컴파일러를 사용하여 ts(TypeScript)파일을 js(JavaScript) 파일로 변환, 쉽게 통합 정적 유형 검사 제공 클래스 기반 객체를 만들 수 있음 클래스 기반이므로 객체 지향 프로…","frontmatter":{"categories":"js ts","title":"javascript vs typescript","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_5/"}}},{"node":{"id":"64a441c6-15e8-577b-8c61-0813430d5ca7","excerpt":"webpack이란? Webpack은 모듈 번들링이다. html 파일에 들어가는 자바스크립트 파일들을 하나의 자바스크립트 파일로 만들어주는 방식을 모듈 번들링이라고 한다. 쉽게 말하자면, 많은 자바스크립트 파일을 하나의 자바스크립트 파일로 만들어 주는 것을 Webpack이라고 한다. webpack은 왜 사용해야할까? 옛날에는 페이지마다 새로운 html을 요청해서 뿌려주는 방식이였다면, 요새는 SPA 하나의 html 페이지에 여러 개의 자바스크립트 파일들이 포함한다. 연관되어 있는 자바스크립트 파일들을 하나의 파일로 묶어줘서 관리하기 편하다. 또한 파일을 컴파일 할 때, 여러 모듈들의 파일을 읽어오는데 시간이 오래 걸리는데, 이러한 문제를 해결하기 위해 여러 파일을 하나의 파일로 번들링 해주고, 하나의 자바스크립트 파일로 만들어서 웹페이지 성능 최적화를 해준다. webpack-dev-server webpack-dev-server는 라이브 리로드 기능을 제공하는 개발용 서버다. 빌드를 …","frontmatter":{"categories":"frontend","title":"webpack이란","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_4/"}}},{"node":{"id":"f9161340-b2a1-530a-9b73-dafb9c77680c","excerpt":"브라우저의 렌더링 과정 브라우저는 HTML, CSS, Javascript, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM과 CSSOM를 생성하고 이들을 결합하여 렌더 트리를 생성한다. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행한다. 이 때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)를 게산하고 브라우저 화면에 HTML 요소를 페인팅한다. HTTP 1.1과 HTTP 2.0 HTTP는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜이다. 이 가운데 HTTP/1.1과 HTTP/2.0의 차이점을 알아보자. HTTP …","frontmatter":{"categories":"frontend","title":"브라우저의 렌더링 과정","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_3/"}}},{"node":{"id":"3ecb7941-dbb4-5d02-959b-dfd107a449e5","excerpt":"호이스팅이란? 변수, 함수가 선언되기 전에 변수명, 함수명을 알고있는 것 var, let, const 모두 호이스팅이 되지만, let과 const는 선언 전까지 변수에 접근이 불가합니다. 호이스팅이 되더라도 접근을 막는 방법 let과 const는 변수가 되기 전까지 TDZ에 들어있다. var은 선언과 동시에 undefined 할당받아서, 에러 처리를 하기 어렵다. 함수 선언식을 사용하면 안되는 이유 같은 함수를 중복 선언을 해도 에러가 뜨지 않고 잘 실행된다. 이것은 협업에 있어 정말 나쁘다.. 이런 일이 발생하지 않도록 함수 표현식을 사용하거나 화살표 함수를 사용하자!","frontmatter":{"categories":"JS","title":"hosting","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_2/"}}},{"node":{"id":"c981ea3d-9067-542f-8bda-fa3409635668","excerpt":"async와 await라는 특별한 문법을 사용하면 promise를 좀 더 편하게 사용할 수 있다. async, await는 매우 편리하고, 사용법도 어렵지 않다. async 는 function 앞에 위치한다. function 앞에 를 붙이면 해당 함수는 항상 promise를 반환한다. promise가 아닌 값을 반환하더라도 이행 상태의 promise(resolved promise)로 감싸 이행된 promise가 반환되도록 한다. 아래 예시의 함수를 호출하면 가 1인 이행 Promise가 반환된다. 가 붙은 함수는 반드시 promise를 반환하고, promise가 아닌 것은 promise로 감싸 반환한다. 또한 는 함수 안에서만 동작한다. 란 무엇인지 알아보자. await  문법은 아래와 같다. 자바스크립트는 키워드를 만나면 promise가 처리될 때까지 기다린다(정말 뜻 그대로 기다림). 결과는 그 이후 반환된다. 1초 후 실행되는 promise를 예시로 사용하여 가 어떻게 동작하…","frontmatter":{"categories":"JS","title":"async, await","date":"August 26, 2022"},"fields":{"slug":"/codecamp_blog_1/"}}},{"node":{"id":"e7a9ec21-3232-5000-ac52-d63563f5044b","excerpt":"어느덧 코드캠프 2달 차,,, 요새는 하루가 정말 짧다… 알고리즘은 하루에 한 문제씩 꼭 풀려고 하는 편이다. 하지만 최근 2주동안은 개인 포트폴리오를 만드느라 정신이 없었다 😵‍💫 수업도 2달차가 되니까 중요한 내용들이 너무 많이 나와서 머릿 속에 넣기 바빴다.. 평소에 관심이 많던 Recoil도 배우고, accessToken과 cookie에 refreshToken을 넣어 로그인을 구현하는 법도 익혔다. 또 React와 가장 다른 점인 Next.js의 hydration이나 Callback, Promise, await/async 등 자바스크립트의 핵심 개념에 대해서도 배웠다. 개인적으로 가장 어려웠던 건.. 권한 분기부분이었는데 비회원 장바구니 구현을 하는 것이 생각처럼 작동하지 않아서 정말 새벽까지 붙잡고 있었다 🤯 왜냐면 굳이 recoil을 쓰고 싶다고 낑낑거렸다,, 일반 회원이 쓰는 장바구니는 recoil을 쓰는 것도 괜찮은 방법이나, 비회원 장바구니 같은 경우는 민감한 정보도 …","frontmatter":{"categories":"회고","title":"코드캠프 2달차 회고","date":"August 15, 2022"},"fields":{"slug":"/codecamp-2/"}}},{"node":{"id":"8afc2905-b73f-5c76-8757-822346fd3241","excerpt":"부트캠프에 들어온 이유 💫 패스트캠퍼스 프론트엔드 과정을 수료하고, 마지막 프로젝트인 기업 연계 프로젝트를 진행하면서 스스로 많이 부족하다는 것을 깨달았다 🥲\n간단한 폼을 만들어서 api를 연결하는 것도 밤을 새가면서 했다.. 또 마지막엔 git branch가 꼬여서 메인 브랜치에 반영되지 않았다..😇\n자괴감이 컸지만.. 왜 실패했는지에 대한 이유를 정확히 바라봐야했다. 이유는 자바스크립트에 대한 개념이 제대로 잡혀있지 않아서 React나 Vue 같은 프레임워크를 쓰는 것에 많은 어려움을 느꼈다. 그래서, 수료 후 개발자 커뮤니티에서 자바스크립트 Deep Dive 책을 같이 읽으면서 토론하는 스터디에 참여하여 기본기를 쌓았다.\n덤으로 현직자들과의 소통을 하면서 여러 정보들을 얻을 수 있었는데, 그 중에서 어떤 분이 자바스크립트의 기본을 탄탄히 하는 것은 좋으나\n빠른 취직을 위해서라면 좋은 방법이 아닌 것 같다는 피드백을 받았다. 수료 후 하반기 취업을 목표로 하고 있었기 때문에, …","frontmatter":{"categories":"회고","title":"코드캠프 1달차 회고","date":"July 28, 2022"},"fields":{"slug":"/codecamp-1/"}}},{"node":{"id":"143e6bcd-a91d-5e59-850a-a96ccc684b6e","excerpt":"데이터를 받아와 화면에 뿌려줄 때 자주 쓰이는 배열 메서드! 쓸 때마다 매번 헷갈려서 구글링을 한다..🥲 게다가 배열 메서드마다 성능이 다 다르기 때문에, 용도에 따라서 어떤 것이 더 편하기도 하다. 확실하게 개념도 파악할 겸 블로그에 정리해놓고 필요할 때마다 보려고한다! for 가장 빠르고 단순하다. 모든 자료형에서 사용할 수 있다. continue / break 사용 가능 forEach forEach는 각 배열 요소에 대해 한 번씩 callback 함수를 실행한다. map과 reduce와는 달리 undefined를 반환하기 때문에 메서드 체인의 중간에 사용할 수 없다. 위에서 본 for문은 실무에서 잘 쓰이지 않는다.(계산이 많이 필요한 서비스라면 얘기가 달라진다) 가독성이 별로 좋지 않기 때문이다. forEach는 for문보다 가독성이 좋고, 복잡한 객체를 처리하는데 있어서 유리하다. 하지만, forEach문은 구문 밖으로 return 값을 받지 못한다는 단점이 있다. for…","frontmatter":{"categories":"JS","title":"자바스크립트 배열 메서드 마스터하기","date":"July 14, 2022"},"fields":{"slug":"/master-array-method/"}}},{"node":{"id":"fcd6528d-5459-5551-a445-d5c448784466","excerpt":"Atomic Pattern이란?  atomic pattern이란, 소스코드를 아주 작은 컴포넌트 단위로 먼저 쪼개는 방법을 의미한다. 이렇게 하는 이유는 컴포넌트의 중복을 최소화 하기 위함이다. 총 5개의 폴더 구조로 이루어지며, 화학점 관점에서 영감을 얻은 디자인 패턴이다. 개발에만 적용되는 개념이 아니며, 디자인의 세계에서도 널리 알려진 패턴이다. 따라서, atomic pattern을 사용하면 디자이너와의 협업에서 유리해질 수 있고, 프로젝트 시작부터 체계적인 UI적 설계가 가능해진다. 현재 웹 프론트 개발에 가장 많이 쓰이는 프레임워크인 React, Vue, Flutter 모두 컴포넌트 단위로 개발을 진행하기 때문에 이러한 컴포넌트 중심 설계 패턴이 더욱 주목 받게 되었다. 하지만, 프로젝트 시작부터 UI를 디자이너와 함께 설계해야하므로 실제 개발 준비까지 걸리는 시간이 오래 걸릴 수 있다. 따라서 시간, 비용, 팀의 상황 등에 따라 적용하는 것이 일반적이다. 그렇다면 각 컴…","frontmatter":{"categories":"fronted","title":"Atomic Pattern이란?","date":"July 11, 2022"},"fields":{"slug":"/about-atomic-pattern/"}}},{"node":{"id":"d4862210-2f10-540a-ac00-28b0df9284b7","excerpt":"Git과 Github 차이점 본론에 들어가기 앞서, 은근 헷갈리기 쉬운 주제를 정리해보자.\n간단해보일지라도 면접에서 물어본다면 머리가 하얘질 수 있다,,, Git : 오픈 소스 버전 관리 시스템 Github : 클라우드 서버를 이용해서 로컬에서 버전 관리한 소스코드를 업로드함. 소스 코드 공유가 가능한 원격 저장소 Git 명령어 명령어 기능 설명 git init 저장소 초기화 git status 현재 상태 확인 git add 현재 상태 추적 git commit 현재 상태 저장 git push 원격 저장소에 공유 git clone 원격 저장소 복제 git pull 원격 저장소에서 로컬로 업데이트 git log 이력 확인 git reset 이전 상태로(이력 제거) git revert 이전 상태로(이력 유지) git switch 브랜치 변경 git merge 브랜치 합치기 git restore 워킹 트리의 파일을 복원 Git의 기초  워킹 디렉토리의 모든 파일은 크게 Tracked(관리…","frontmatter":{"categories":"tool","title":"Git 마스터 하기","date":"July 06, 2022"},"fields":{"slug":"/about-git/"}}},{"node":{"id":"03463685-50ef-59b4-ae09-dadfb62bcb70","excerpt":"갑작스런 코로나 확진으로 인한 잔디밭 가뭄사건.. 🥲 잔디밭과 함께 비워진 머리를 다시 성장 욕구로 채우기 위해 강의를 들었다.\n마침 원티드에서 신입 개발자를 위해 관련된 콘텐츠 패키지를 무료로 볼 수 있게 풀어줘서 바아로 신청했다. 나이스 타이밍 👍🏻 📢 연사 Puzzle AI 강병진, 위코드 김예리 🌱 Part1. 누구보다 빠르게 성장하기 주 40시간으로는 세상을 바꿀 수 없다. 일단 만든다! 사이드 프로젝트 🌱 Part2. 개발자의 커뮤니케이션과 네트워킹 개발자들은 기본적으로 협업을 하기 때문에, 커뮤니케이션과 네트워킹이 중요하다고들 한다. 이유가 뭘까? 나한테 당연한 게 남한테도 당연한 것은 아니다. ‘내가 이 정도 말하면 이해했겠지?‘라고 생각해도 상대방은 좀 더 자세한 설명을 원할 수 있다.\n소통을 할 때, 내가 하고 싶은 대로 하는 것이 아니라 상대방에게 초점을 맞춰 이해할 수 있도록 하는 것이 중요하다. 개발자 모임에 적극적으로 참여하거나 명함을 주거나 내가 개발자라는…","frontmatter":{"categories":"lecture","title":"빠르게 성장하고 싶은 주니어 개발자를 위한 로드맵","date":"May 25, 2022"},"fields":{"slug":"/lecture-junior-loadmap/"}}},{"node":{"id":"ae9f3dff-6b00-5d54-a988-6256258508c1","excerpt":"본론으로 들어가기 전 최근 FE 재남님이 라이브로 코딩하시는 걸 봤었는데, REST API보다 GraphQL이 편리한 이유에 대해서 설명하시는 걸 듣고 graphQL을 공부하고 싶어졌다. 공부하기 전에는 쿼리 언어라고 하길래 데이터베이스 관련이구나 하고 지나갔었는데,, 묘하게 반전.. 😬 이제 REST API보다 GraphQL을 쓰고 싶어진 이유에 대해 알아보자. graphQL이란? GraphQL은 Facebook이 만든 API에 대한 쿼리 언어이다. GraphQL은 API에 대한 쿼리 언어이며 기존 데이터로 이러한 쿼리를 수행하기 위한 런타임입니다. GraphQL은 API의 데이터에 대한 완전하고 이해하기 쉬운 설명을 제공하며, 고객에게 필요한 것이 무엇이며 그 이상의 것이 없는지 정확히 물어볼 수 있는 힘을 제공하며, 시간이 지남에 따라 API를 더 쉽게 개발할 수 있도록 하며, 강력한 개발자 도구를 지원합니다. graphQL은 어떠한 문제를 해결할 수 있나? 일단 GraphQ…","frontmatter":{"categories":"frontend","title":"REST API보다 graphQL을 쓰고 싶은 이유","date":"May 16, 2022"},"fields":{"slug":"/what-about-graphql/"}}},{"node":{"id":"0d4985e4-75d9-520c-9d73-c77719c5439b","excerpt":"React의 특징은 무엇일까 면접에서 빼놓을 수 없는 React 관련 질문들 중 React의 특징에 대해서 알아보자 😉 1. 컴포넌트 기반 설계 의미 단위로 컴포넌트 구성 재사용성과 유지보수성 증가 부모, 자식 관계를 가짐 2. Virtual DOM 일반적으로 우리가 자바스크립트를 이용하여 DOM을 변경할 때, 브라우저가 DOM을 재구축하고 화면을 그리는 과정을 거치게 된다. 하지만 잦은 DOM 변경은 웹 사이트의 성능 문제를 야기한다. 그래서 React는 virtual DOM(가상돔)을 하나 만들어두고, 변경되어야할 DOM 요소를 미리 virtual DOM에서 모두 변경해두고 이것을 DOM(찐)에서 동기화시키는 방식을 사용한다. 이런식으로 하게 되면 DOM을 직접 변경시킬 때 발생하는 비효율을 어느정도 해결할 수 있게 된다. 3. 높은 자유도 컴포넌트는 고립되어 있고, 독립적이며 재사용이 가능하다. 그렇기 때문에 unit test가 가능해진다. Unit text란, 유닛 테스트의…","frontmatter":{"categories":"frontend","title":"React의 특징","date":"May 15, 2022"},"fields":{"slug":"/react-characteristic/"}}},{"node":{"id":"be23dd6c-5b7a-57a1-9e26-ce2a96a52404","excerpt":"이미지의 중요성 최근 들어, 초고속망 인터넷과, 그에 따른 사용자의 니즈로 인하여 웹페이지는 무게는 점점 더 무거워지고 있다. 위 사진을 보면, 2017년엔 1420.8kb이던 웹사이트의 무게가 2022년 현재는 2203.8kb로 무려 55%나 무거워졌기 때문이다. 특히 E-Commerce는 사이트 특성상 사진이 많이 들어가고, 상품을 팔기 위해선 사진은 빠질 수 없는 가장 중요한 요소이며, 이미지의 사이즈는 판매와도 직결되는 부분이다. 왜냐하면 KissMetrics의 연구 결과에 따르면 페이지 로딩이 약 1초씩 느려질 때마다 상품을 구매하는 사용자의 비율은 약 7%씩 감소할 수 있다고 한다. 그러므로 이미지 최적화는 프론트엔드 개발자의 숙명이라고 할 수 있다. 웹사이트 이미지 체크 HTTP 아카이브 연구에 따르면 평균 웹사이트의 반 이상이 이미지로 이루어져 있으며, 이미지의 용량도 다른 콘텐츠에 비해 월등히 높다고 한다. 따라서 이미지의 사이즈를 적절히 줄이고, 렌더링 속도를 빠…","frontmatter":{"categories":"web","title":"이미지 최적화","date":"May 11, 2022"},"fields":{"slug":"/image-optimization/"}}},{"node":{"id":"042e5c57-78ee-5607-8329-698fb7014144","excerpt":"introduction 는 코딩 컨벤션에 위배되는 코드나 안티 패턴을 자동 검출하는 도구다. 처음부터 유용하게 사용할 수 있는 스타일 가이드(built-in rule)을 제공하지만 개발자가 자신의 스타일 가이드를 작성할 수도 있다. 는 코드의 최대 길이, 함수에서, 작은따옴표(‘)를 사용할 것인지 아니면 큰 따옴표(“)를 사용할 것인지 등 코드가 예쁘게 보이도록 하는지에 중점을 두었다. 하지만 코드의 에러를 잡아내진 못한다. install eslint & Airbnb style guide 를 기본으로 와 필요 플러그인들을 로컬 설치하자. 를 전역으로 설치할 수도 있으나 권장하지 않는다. 만약 전역으로 설치할 경우에는 공유 설정과 필요 플러그인을 로컬 설치해 주어야 한다. 참고로 이 글에서의 스타일 가이드는 에 대한 설명도 들어있지만, 와 를 사용한다는 가정하에 작성되었다. 플러그인 설명 eslint-config-airbnb Airbnb의 style guide를 eslint의 설정 …","frontmatter":{"categories":"environment","title":"eslint, stylelint 설정하기(with VSCODE)","date":"May 10, 2022"},"fields":{"slug":"/eslint-setting/"}}},{"node":{"id":"394b3165-1fda-58ab-870b-a1db5979e079","excerpt":"스터디에 참여한 이유 자바스크립트에 대한 기초가 부족한 채로 SPA 프레임워크를 사용하여 프로젝트를 해오니 간단한 오류 하나 잡는 것에도 시간이 많이 들었다. 최신 기술 스택들을 따라가기 보다는 기초가 튼튼한 개발자가 되어야겠다고 마음을 먹고, okky를 통해서 스터디를 찾아 참여하게 되었다. 스터디 진행 스터디는 게더타운에서 평일 밤 10시에 모여 진도에 맞는 챕터를 각자 1시간동안 읽고, 토론을 하는 식으로 진행했다. 보통 30분 정도 토론을 했고, 길어지면 12시를 넘기는 날도 있었다. 진도를 다 끝내는 데 2달 정도 걸렸다. 학생, 취준생, 현업자로 다양한 사람들로 구성되었다. 마지막엔 나 포함 2명밖에 남지 않았지만.. 스터디 내내 개발 초보가 보는 관점과 현업에 계신 분의 관점이 이렇게 다르구나를 느낄 수 있었다. 역시 아는 만큼 보인다..! 모던 자바스크립트 Deep Dive 스터디 레포지토리를 통해 진도 체크를 하였고, 자유롭게 글을 올리는 식으로 진행되었다. 난 T…","frontmatter":{"categories":"회고","title":"모던 자바스크립트 Deep Dive 스터디 회고","date":"May 01, 2022"},"fields":{"slug":"/js-deep-dive-study/"}}},{"node":{"id":"05c02b84-3ca2-596b-9ab0-e179853bef35","excerpt":"CRA를 쓰는 이유 페이스북에서 개발한 Create-React-App(CRA) 보일러 플레이트를 사용하면 간편하게 리액트로 웹 애플리케이션을 만들 수 있다. CRA는 개발 환경을 구성할 때 필요한 여러가지 라이브러리나 웹팩의 설정 없이 쉽게 프로젝트를 시작할 수 있다. CRA에 대한 장점을 정리해보자. One Dependency\none build dependency를 가진다. Webpack, babel, ESLint 등을 사용하지만 응집력 있는 큐레이션된 경험을 제공한다. No Configuration Required\n개발 환경을 위해 많은 것을 설정하지 않아도 된다. CRA는 프로젝트에 필요한 필수적인 설정(Configuration)을 대신 해준다. CRA는 Autoprefixer를 지원해준다. 즉, 일반적인 CSS코드 생성을 하게 되면 자동으로 -webkit-, -ms- 등을 자동으로 적용해준다. CRA를 이용하면 기존 기능을 개선하거나 새로운 기능을 추가했을 때 패키지 버전만…","frontmatter":{"categories":"frontend","title":"Create-React-App에서 eject를 하면 안되는 이유","date":"April 29, 2022"},"fields":{"slug":"/you-shouldnt-do-eject/"}}},{"node":{"id":"34bef439-be79-54a0-8aaa-72dc91291aaa","excerpt":"객체지향 프로그래밍? 함수형 프로그래밍? 모던 자바스크립트 deep dive 스터디를 하면서, 자바스크립트 세계는 모든 것이 객체로 이루어져있다는 것을 보고 객체지향 프로그래밍을 배워야하는 것인가, 하지만 요새는 함수형 프로그래밍이 대세라던데..? 라는 주제로 팀원들과 얘기를 나눈 적이 있다. 잘은 모르겠지만 함수형 프로그래밍을 배워야한다로 결론이 났던 것 같은데, 이 글에서 이유를 자세히 알아보자 🤓 왜 함수형 프로그래밍을 배워야하나?   재미 / 실시간성 라이브 방송, 실시간 댓글, 협업, 메신저 독창성 / 완성도 애니메이션, 무한 스크롤, 벽돌 더 많아져야하는 동시성 비동기 I/O, CSP, Actor, SMT … 대용량 / 정확성 / 병렬성 MapReduce, Clojure Reducers… 복잡도 / MSA / … 많아지고 세밀해지는 도구들 예전에는 하나의 프레임워크가 전체의 구현을 대신하고, 해당 서비스의 구체화되는 부분만 알려주면 그 프레임워크가 모든 것을 동작 시켰다…","frontmatter":{"categories":"JS","title":"웹개발에서 함수형 프로그래밍이 대세다?","date":"April 15, 2022"},"fields":{"slug":"/functional-programming/"}}},{"node":{"id":"0b4633a0-520f-5d83-8591-f43e40841344","excerpt":"🌱 주제 피드백 주도 성장, 성장할 수 밖에 없는 환경 만들기 📢 연사 우아한형제들 장현석, 임동준 🍯 정리 현실에서는 게임처럼 레벨이나 경험치가 나와있는 것도 아니기에 성장에 대한 수치를 한 눈에 알아보기 어렵다.\n그렇다면, 현실에서 게임과 같이 피드백 시스템 환경을 어떻게 구축해야될까? Part1. 혼자 보단 동료와 함께 보통 혼자 취업 준비를 하면 긴박함에 갇혀서 숲을 보지 못하고, 코 앞의 나무만 보일 수 밖에 없다. 이런 걸 터널비전이라고 하는데, 여기에 갇혀있기 보다 시야 밖에 있는 사람들과 소통할 수 있는 환경을 만드는 것이 좋다. 이렇게 소통을 통해서 피드백을 받는다면 부족한 점을 파악하기 쉽고, 그 만큼 성장욕구도 얻을 수 있다. 훌륭한 의사소통은 블랙커피처럼 자극적이며, 후에 잠들기가 어렵다. - A.M. 린드버그(미국의 작가, 수필가) Part2. 구체적인 경험치를 얻는 방법 : 피드백 loop 만들기 스터디 같은 모임을 통해서 피드백을 얻는 방법도 좋지만, 우…","frontmatter":{"categories":"lecture","title":"[우테코X원티드] 오늘의 개발자 : 프론트엔드1","date":"April 06, 2022"},"fields":{"slug":"/lecture-growth/"}}},{"node":{"id":"e92fa63b-4c08-546e-9367-bb9591e2a00d","excerpt":"자바스크립트로 api키 숨기기 시도 🏋️‍♀️ 그러나 실패,,,! .env나 웹팩이 아닌 순수 자바스크립트로 api키를 숨기기 위해 apikey.js에 api 객체를 만들고, .gitignore에 apikey.js를 추가하여 숨기는 방법을 사용했는데… 찾아보니 ajax 방식으로 보내는 거라서 개발자 도구에서 정보가 줄줄 샌다고 한다.. 실제로 네트워크탭을 열어보니 api키가 훤히 보인다 😇 무료 api라서 크게 상관없지만, 실제 현업에서는 어떤 식으로 처리해야하는지 궁금하다..! 이건 다음에 글로 정리해보겠음 💪🏻 그렇다면, ajax 방식이란 무엇일까? ajax ajax란 Asynchronous JavaScript and XML의 약어로, 서버와 비동기적으로 데이터를 주고받는 자바스크립트 기술을 의미한다. 웹 페이지 전체를 다시 로딩하지 않고도 서버에 GET 요청을 날릴 수 있는 js 코드라고 이해하면 된다. 장점 : 새로고침이 없으니까 웹페이지 전환이 부드러워짐 한계 : Ajax를 이용하…","frontmatter":{"categories":"web","title":"AJAX란 ?!","date":"April 05, 2022"},"fields":{"slug":"/about-ajax/"}}},{"node":{"id":"b05632b8-84cf-5574-b399-2858b0e1bcc1","excerpt":"오늘은 BEM 방법론에 대해 얘기해보려해요 😃 BEM 공식문서를 보면, BEM(Block, Element, Modifier)이란 웹 개발에 대한 컴포넌트 기반 접근법이라고 나와있어요.\n말이 어렵지만 유지보수를 위한 css 클래스네임에 대한 고민? 이라고 생각하면 될 것 같아요. 1. Introduction 소규모 사이트에서 스타일에 대해 코드를 짤 때 어떻게 구성할 지에 대해서 신경쓰지 않는 것은 보통 큰 문제가 되지 않아요.\n하지만, 규모가 크고 복잡한 프로젝트의 경우 다음과 같은 3가지 이유로 아주 중요해집니다. 코드 작성 시간에 영향을 끼친다. 써야하는 코드의 양에 영향을 끼친다. 브라우저가 로딩해야하는 양에 영향을 끼친다. 또한 팀과 협업해야 할 때, 그리고 좋은 퍼포먼스가 필수적일 때 특히 중요해요. 레거시 코드와 함께 긴 기간 진행되는 프로젝트들에도 역시 중요합니다. 2. Methodologies CSS 설치 공간을 줄이고, 개발자 간의 협력을 구성하며 대규모 CSS 코…","frontmatter":{"categories":"style","title":"BEM 방법론","date":"March 24, 2022"},"fields":{"slug":"/what-is-BEM/"}}},{"node":{"id":"e94c82d1-4c13-5f60-a35e-a9f0249a49d5","excerpt":"개인적으로 element에 텍스트를 추가하고 싶을 때는 innerText를 사용하는 편이에요. 두 프로퍼티는 어떤 공통점과 차이점을 가지고 있는지 궁금해져서 정리해보려고 합니다 ! 공통점 🍯 둘 다 텍스트노드를 추가해요. 텍스트를 추가한다는 공통점이 있어요. 결과 역시 동일해요. 해당 element의 텍스트 값을 반환해요. 즉, 어떤 텍스트를 가지고 있는지 알 수 있어요. 차이점 👻 는 와  요소를 포함한 모든 요소의 콘텐츠를 가져옵니다. 반면 는 “사람이 읽을 수 있는” 요소만 처리해요. 즉, 는 모든 텍스트를 그대로 가져오지만, 는 불필요한 공백을 제거하고 텍스트로 반환하는 차이점이 있어요. textConent가 먼저 만들어졌고, 더 빨리 사용되었다고 해요. 이런 이유로 브라우저 호환성도 좀 더 높습니다. 또한 큰 차이는 아니지만 더 가볍다고 알려져 있어요. 예를 들어, 아래와 같은 태그가 있다고 가정해볼게요. 이 때, innerText와 textContent의 결과는 다릅니다…","frontmatter":{"categories":"JS","title":"innerText vs textContent","date":"March 16, 2022"},"fields":{"slug":"/about-innerText-textContent/"}}},{"node":{"id":"d36652d6-8d98-50a3-8eb4-39169d2807ca","excerpt":"들어가기에 앞서.. 파이널 프로젝트를 하면서, 싱크업 미팅 때 홈페이지 인덱스 쪽을 SSR로 개발해달라는 기업 측 요구사항이 있어서 공부할 겸 정리를 해보려고 합니다 😃 CSR란 무엇인가?  CSR란 Client Side Rendering의 약자로, 클라이언트가 렌더링을 하는 방식을 말합니다. 우리가 웹사이트에 접속하게 되면, 빈 HTML 파일을 먼저 다운받게 됩니다. 그래서 이 HTML 파일 안에 있는 DOM 요소나 스타일들이 보이게 되죠.\n이 다음 단계부터는 리액트를 예시로 들겠습니다. 리액트는 자바스크립트로 이루어진 커다란 웹 애플리케이션입니다. 그렇기 때문에 자바스크립트 전체가 다운이 완료되어야지 리액트가 실행됩니다. 이후 한마디로 전체 자바스크립트 파일이 다운되어서 실행되기 전까지 우리는 리액트 앱 화면을 볼 수 없다는 말이죠. 🥲 리액트가 실행되면 리액트 컴포넌트들이 화면에 그려지게 되고 그제서야 화면을 볼 수 있게 되고, 유저가 인터랙션을 할 수 있게 됩니다. 이후 필…","frontmatter":{"categories":"web","title":"CSR, SSR이 뭐예요?","date":"January 09, 2022"},"fields":{"slug":"/whta-is-CRS-SSR/"}}},{"node":{"id":"9edb0306-4a3f-5fc1-a59d-da4955498907","excerpt":"💅 예쁘면 장땡 처음 개발 블로그를 만들 때는 velog를 이용했다. 마크다운을 지원해서 글쓰는 것도 편하고, 무엇보다 사이트가 깔끔하고 예뻤다. 태그를 달아 카테고리 별로 보기 쉽게 정리할 수도 있었다. 그치만.. 잔디밭을 심지 못한다는 단점이 있어서 Jeykll이나 Hexo를 이용하여 github blog를 만들기도 했다. 하지만 테마가 마음에 들지 않아 글을 쓰고 싶은 마음이 들지 않았다. 핑계인가..ㅎ 그렇게 github 파도타기를 하며 예쁜 테마를 찾던 중, zoomkoding-gatsby-blog 템플릿이 눈에 들어왔다.\n예.뻤.다. ✨ ✅ Gatsby의 장점 Jekyll은 Ruby 기반으로 만들어져 있고, Gatsby는 React 기반으로 만들어졌다.\n현재 React를 공부하고 있고, 앞으로도 React를 현업에서 많이 쓸 예정이기 때문에 Gatsby를 사용하는 것이 블로그 세팅이 더 쉬울 것이라는 판단을 했다. 또한 개발자들이 서로 다른 콘텐츠, API 및 서비스를 …","frontmatter":{"categories":"frontend","title":"Gatsby로 github blog 만들기","date":"January 06, 2022"},"fields":{"slug":"/make-gatsby-starter-zoomkoding/"}}}]},"site":{"siteMetadata":{"language":"ko","author":{"name":"이지혜","bio":{"role":"개발자","description":["매일 더 성장하는","끝까지 해내는","이로운 것을 나누고픈"],"thumbnail":"memoji.png"},"social":{"github":"https://github.com/leedawnn","linkedIn":"https://www.linkedin.com/in/ji-hey-lee-0175b9224/","email":"dev.leedawn@gmail.com"}}}}},"pageContext":{}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437","3350743975"]}