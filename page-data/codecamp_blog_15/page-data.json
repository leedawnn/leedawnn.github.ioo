{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/codecamp_blog_15/",
    "result": {"data":{"cur":{"id":"81024205-7b63-5daf-90e4-5b9b1659a28c","html":"<h3 id=\"react의-생명주기-life-cycle이란\" style=\"position:relative;\"><a href=\"#react%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-life-cycle%EC%9D%B4%EB%9E%80\" aria-label=\"react의 생명주기 life cycle이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React의 생명주기 (Life Cycle)이란</h3>\n<p>React 컴포넌트는 생명주기 즉 life cycle이란게 있는데, 이건 컴포넌트나 실행되거나 업데이트 혹은 제거될때 특정한 이벤트들이 발생한다.</p>\n<h3 id=\"mount\" style=\"position:relative;\"><a href=\"#mount\" aria-label=\"mount permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mount</h3>\n<p>컴포넌트가 처음 실행될 때 그것을 Mount라고 표현한다. 컴포넌트가 시작되면 우선 context, defaultProps와 state를 저장한다. 그 후에 componentWillMount 메소드를 호출한다. 그리고 render로 컴포넌트를 DOM에 부착한 후 Mount가 완료된 후 componentDidMount가 호출된다.</p>\n<p>주의할 점은, componentWillMount에서는 props나 state를 바꾸면 안된다. Mount 중이기 때문임. 그리고 아직 DOM에 render하지 않았기 때문에 DOM에도 접근할 수 없다.</p>\n<p>componentDidMount에서는 DOM에 접근할 수 있다. 그래서 여기에서는 주로 AJAX 요청을 하거나, setTimeout, setInterval같은 행동을 한다.</p>\n<h3 id=\"props-update\" style=\"position:relative;\"><a href=\"#props-update\" aria-label=\"props update permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Props Update</h3>\n<p>props가 업데이트될 때의 과정이다. 업데이트되기 전에 업데이트가 발생하였음을 감지하고, componentWillReceiveProps 메소드가 호출된다. 그 후 shouldComponentUpdate, componentWillUpdate가 차례대로 호출된 후, 업데이트가 완료(render)되면 componentDidUpdate가 된다. 이 메소드들은 첫 번째 인자로 바뀔 props에 대한 정보를 가지고 있다. componentDidUpdate만 이미 업데이트되었기 때문에 바뀌기 이전의 props에 대한 정보를 가지고 있다.</p>\n<p>shouldcomponentUpdate에서는 아직 render하기 전이기 때문에 return false를 하면 render을 취소할 수 있다. 주로 여기서 성능 최적화를 한다. 쓸데없는 update가 일어나면 여기서 걸러내는 거죠.</p>\n<p>주의사항이 있는데, componentWillUpdate에서는 state를 바꿔서는 안된다. 아직 props도 업데이트하지 않았으므로 state를 바꾸면 또 shouldComponentUpdate가 발생한다. componentDidUpdate에서는 render이 완료되었기 때문에 DOM에 접근할 수 있다.</p>\n<h3 id=\"state-update\" style=\"position:relative;\"><a href=\"#state-update\" aria-label=\"state update permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>State Update</h3>\n<p>setState 호출을 통해 state가 업데이트될 때의 과정이다. props update와 과정이 같지만, componentWillReceiveProps 메소드는 호출되지 않는다. 그리고 메소드의 두 번째 인자로는 바뀔 state에 대한 정보를 가지고 있다. componentDidUpdate는 두 번째 인자로 바뀌기 이전의 state에 대한 정보를 가지고 있다.</p>\n<h3 id=\"unmount\" style=\"position:relative;\"><a href=\"#unmount\" aria-label=\"unmount permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unmount</h3>\n<p>컴포넌트가 제거되는 것은 Unmount라고 표현한다. 더는 컴포넌트를 사용하지 않을 때 발생하는 이벤트가 있다. componentWillUnmount가 그것임. componentDidUnmount는 없다. 이미 제거된 컴포넌트에서 이벤트를 발생시킬 수는 없겠죠? componentWillMount에서 주로 연결했던 이벤트 리스너를 제거하는 등의 여러 가지 정리 활동을 한다.</p>","excerpt":"React의 생명주기 (Life Cycle)이란 React 컴포넌트는 생명주기 즉 life cycle이란게 있는데, 이건 컴포넌트나 실행되거나 업데이트 혹은 제거될때 특정한 이벤트들이 발생한다. Mount 컴포넌트가 처음 실행될 때 그것을 Mount라고 표현한다. 컴포넌트가 시작되면 우선 context, defaultProps와 state를 저장한다. 그 후에 componentWillMount 메소드를 호출한다. 그리고 render로 컴포넌트를 DOM에 부착한 후 Mount가 완료된 후 componentDidMount가 호출된다. 주의할 점은, componentWillMount에서는 props나 state를 바꾸면 안된다. Mount 중이기 때문임. 그리고 아직 DOM에 render하지 않았기 때문에 DOM에도 접근할 수 없다. componentDidMount에서는 DOM에 접근할 수 있다. 그래서 여기에서는 주로 AJAX 요청을 하거나, setTimeout, setInterval…","frontmatter":{"date":"August 26, 2022","title":"State and Lifecycle","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_15/"}},"next":{"id":"8cc45da0-e85c-5757-aea5-94889be12746","html":"<h3 id=\"순회iteration\" style=\"position:relative;\"><a href=\"#%EC%88%9C%ED%9A%8Citeration\" aria-label=\"순회iteration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>순회(iteration)</h3>\n<p>순회에 필요한 메서드는 map.keys(), map.values(), map.entries() 등이 있다.</p>\n<p>이 메서드들은 포괄적인 용도로 만들어졌기 때문에 메서드를 적용할 자료구조는 일련의 합의를 준수해야 한다. 커스텀 자료구조를 대상으로 순회를 해야 한다면 이 메서드들을 쓰지 못하고 직접 메서드를 구현해야 한다.</p>\n<p>keys(), values(), entries()를 사용할 수 있는 자료구조는 다음과 같다.</p>\n<ul>\n<li>Map</li>\n<li>Set</li>\n<li>Array</li>\n</ul>\n<p>일반 객체에도 순회 관련 메서드가 있긴 한데, keys(), values(), entries()와는 문법에 차이가 있습니다.</p>\n<p>Object.keys, values, entries 일반 객체엔 다음과 같은 메서드를 사용할 수 있다.</p>\n<ul>\n<li>Object.keys(obj) – 객체의 키만 담은 배열을 반환.</li>\n<li>Object.values(obj) – 객체의 값만 담은 배열을 반환.</li>\n<li>Object.entries(obj) – [키, 값] 쌍을 담은 배열을 반환.</li>\n</ul>","frontmatter":{"date":"August 26, 2022","title":"Object.keys, values, entries","categories":"js","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_17/"}},"prev":{"id":"96e7f4e9-2d4c-5ae5-998d-5afd99a0b109","html":"<p>React에서는 전역상태를 관리하는 라이브러리들이 상당히 존재한다. 상태관리 라이브러리 중 바이블(?)이라고 불리는 Redux가 존재한다.(현재는 Redux toolkit을 사용하길 권장함)</p>\n<p>이 Redux를 포함하여 많은 상태관리 라이브러리가 존재하는데, 하나씩 알아보도록 하자.</p>\n<h3 id=\"전역상태에-대한-정의\" style=\"position:relative;\"><a href=\"#%EC%A0%84%EC%97%AD%EC%83%81%ED%83%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EC%9D%98\" aria-label=\"전역상태에 대한 정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>전역상태에 대한 정의</h3>\n<p>상태관리 라이러리를 소개하기 전, 먼저 <code class=\"language-text\">전역상태가 무엇인가</code>에 대해 얘기해보자.</p>\n<ul>\n<li>우리가 다루어야할 상태가 무엇이 있는지를 정의하고 이를 구분할 수 있어야 함.</li>\n<li>어떤 상태가 들어가야하는지 기획을 생각하고 파악해볼 필요가 있음.</li>\n<li>상태를 나눌 필요가 없다면? 굳이 상태관련 라이브러리를 사용해야 하는가?</li>\n</ul>\n<h3 id=\"글로벌-상태-관리란\" style=\"position:relative;\"><a href=\"#%EA%B8%80%EB%A1%9C%EB%B2%8C-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC%EB%9E%80\" aria-label=\"글로벌 상태 관리란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>글로벌 상태 관리란?</h3>\n<p>전역 상태관리를 사용하면 여러 구성 요소간에 데이터를 쉽게 전달/조작할 수 있습니다. (영구 전달 체인 끊기)</p>\n<h3 id=\"옵션비교\" style=\"position:relative;\"><a href=\"#%EC%98%B5%EC%85%98%EB%B9%84%EA%B5%90\" aria-label=\"옵션비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>옵션비교</h3>\n<h4 id=\"context-api\" style=\"position:relative;\"><a href=\"#context-api\" aria-label=\"context api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Context API</h4>\n<p>Contex API는 React 16.3버전에서 출시된 옵션이다. 컨텍스트 API는 구성 요소 트리에서 쉽게 전달할 수 있는 전역 데이터를 생성한다. 이것은 데이터를 전달하기 위해 props가 있는 구성 요소 트리를 통과해야 하는 \n“props Drilling”의 대안으로 사용되고 있다.</p>\n<ul>\n<li>\n<p>장점</p>\n<ul>\n<li>사용의 간편함</li>\n<li>타사 라이브러리가 필요하지 않다.</li>\n<li>번들 크기를 늘려주지 않는다.</li>\n<li>기본적으로 React 기반으로 구워진다.</li>\n</ul>\n</li>\n<li>\n<p>단점</p>\n<ul>\n<li>속도가 느리다. 컨텍스트의 값이 변경되면 실제로 사용하는지 여부에 관계없이 이 컨텍스트를 사용하는 모든 구성 요소가 다시 랜더링된다. 따라서 빈도가 높은 업데이트 또는 컨텍스트를 통해 전체 응용 프로그램 상태를 공유하는 것은 과도한 렌더링 수명 주기를 유발하며 매유 비효율적으로 로케일, 테마 변경, 사용자 인증 등과 같은 빈도가 낮은 업데이트에만 적합하다</li>\n<li>렌더 성능상의 이슈가 있다</li>\n<li>Context를 사용하면 컴포넌트를 재사용하기가 어려워진다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"redux\" style=\"position:relative;\"><a href=\"#redux\" aria-label=\"redux permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redux</h4>\n<p>Redux는 React 앱의 상태를 중앙 집중식으로 저장하고 관리하는 데 사용되는 상태 관리 라이브러리이다. Redux는 앱의 모든 상태를 하나의 전역화된 상태 객체로 추상화한다.</p>\n<ul>\n<li>\n<p>Redux의 세가지 원칙</p>\n<ul>\n<li>전체 상태 값이 하나의 자바스크립트 객체로 표현된다.</li>\n<li>상태 값은 읽기 전용의 불변 객체로 관리한다.</li>\n<li>오직 순수함수에 의해서만 상태값을 변경할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>장점</p>\n<ul>\n<li>상태 개체의 일부가 업데이트되면 해당 상태를 사용하는 구성 요소만 다시 렌더링 된다.</li>\n<li>Redux는 자주 업데이트되는 앱이 있을때 사용하면 더욱 효율적이다.</li>\n<li>저장소가 업데이트되면 변경되지 않고 업데이트된다. 이전 저장소는 새 상태 값으로 복사된다.이를 통해서 이전 업데이트 및 업데이트 기록을 따라 이동하는 시간과 같은 항목을 추적해 디버깅에 도움을 줄 수 있다. 이렇게 한다면 Redux를 더욱 쉽게 테스트 + 유지 보수 관리 및 확장을 할 수 있다.</li>\n<li>Redux기반으로한 디버깅 도구: Redux DevTools</li>\n<li>상태 관리 라이브러리에서 Redux는 가장 큰 커뮤니티 지원을 제공한다.</li>\n</ul>\n</li>\n<li>\n<p>단점</p>\n<ul>\n<li>많은 상용구와 복잡한 구조를 가진다.</li>\n<li>설치해야할 타사 라이브러리 존재하고 그만큼 번들 크기가 증가한다</li>\n<li>불변 저장소의 단점으로 저장소가 거대한 json 파일로 빠르게 변할 수 있다는 점\n작성해야할 코드가 상대적으로 많아진다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"mobx\" style=\"position:relative;\"><a href=\"#mobx\" aria-label=\"mobx permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MobX</h4>\n<p>MobX는 상태 관리를 간단하게 만들기 위한 기능적 반응 프로그래밍(예: @observable)을\n적용하는 상태관리 라이브러리이다.</p>\n<ul>\n<li>\n<p>장점</p>\n<ul>\n<li>Mobx는 @observable을 사용하여 구독을 통해 변경 사항을 자동으로 추적한다.</li>\n<li>이것은 Redux 개발자가 리듀서에서 데이터를 복제하고 변경 불가능하게 업데이트하는 오버헤드를 제거한다.</li>\n<li>Redux에 비해서 상용구가 적다. 그만큼 배우기 쉬움</li>\n<li>MobX는 여러 저장소를 지원하지만 Redux는 단일 저장소를 허용한다. 이를 통해서 UI상태와 도메인 상태(서버 API 데이터)에 대한 별도의 저장소를 가질 수 있다. UI 상태가 별도로 유지되기 떄문에 도메인 상태를 서버 데이터와 일치하게 유지하고 서버에 연결하는 것을 간단하게 만들 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>단점</p>\n<ul>\n<li>업데이트 중에 MobX 상태를 덮어쓴다. 구현하기에는 쉽지만 저장소가 훨씬 덜 예측가능하기 때문에 테스트 및 유지 관리가 어려울 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"swr\" style=\"position:relative;\"><a href=\"#swr\" aria-label=\"swr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SWR</h3>\n<p>SWR은 Next.js에서 개발한 zeit 그룹에서 사용하는 라이브러리입니다. \nSWR은 맨처음 cache(캐시)로 부터 받아온 데이터 즉, 오래된 정보를 먼저 리턴 해주고 그 다음 fetch를 한 다음 마지막으로 업데이트된 데이터를 다시 리턴해줍니다. 이러한 로직을 통해서 UX의 향상을 만들어 낼 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Home</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">,</span> error <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useSWR</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/home'</span><span class=\"token punctuation\">,</span> fetcher<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>ERROR...&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>isLoading....&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>{data.name}&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>\n<p>장점</p>\n</li>\n<li>\n<p>데이터가 캐싱된다.</p>\n</li>\n<li>\n<p>SWR은 자동으로 재검증을 해준다.</p>\n</li>\n<li>\n<p>Revalidate on Focuspage에 re-focus하던가 tab을 변경했을 때, SWR은 자동으로 데이터를 재검증한다. 이로써 최신 상태로 데이터를 즉시 동기화하는 데 유용오래된 모바일 탭 또는 절전 모드가 된 노트북과 같은 환경에서 데이터를 새로 고치는 데 유용\nRevalidate on IntervalSWR은 설정한 Interval 이후 데이터를 자동으로 다시 가져 오는 옵션을 제공</p>\n</li>\n<li>\n<p>Revalidate on Reconnect데이터가 항상 최신 상태인지 확인하기 위해 SWR은 - 네트워크가 복구 될때 자동으로 재검증 사용자가 다시 온라인 상태가 될때 유효성을 다시 확인할 수 있도록 한다.</p>\n</li>\n</ul>\n<p>SWR을 이용하면 의존데이터를 쉽게 가져올 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function MyProjects() {\nconst { data: user } = useSWR(`api/user`)\nconst { data: projects } = useSWR(() => 'api/projects?uid=' + user.id)\n\nif (!projects) return \"loading...\"\nreturn 'You have ' + projects.length + 'projects'\n}</code></pre></div>","frontmatter":{"date":"August 26, 2022","title":"React 상태관리","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_14/"}},"site":{"siteMetadata":{"siteUrl":"https://leedawnn.github.io","comments":{"utterances":{"repo":"leedawnn/leedawnn.github.io"}}}}},"pageContext":{"slug":"/codecamp_blog_15/","nextSlug":"/codecamp_blog_17/","prevSlug":"/codecamp_blog_14/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}