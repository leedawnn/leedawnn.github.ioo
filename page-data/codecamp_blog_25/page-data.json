{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/codecamp_blog_25/",
    "result": {"data":{"cur":{"id":"771a4588-c92f-5b5f-b2a7-9e42e82d0add","html":"<p>재귀함수란 함수의 호출결과로 함수를 리턴하는 함수를 말한다.</p>\n<p>알고리즘뿐만 아니라 여러가지로 많이 쓰이는 기법이다.</p>\n<p>간단한 예를 들어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">11</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\nsum <span class=\"token operator\">+=</span> i\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 55</span>\n위의 코드는 <span class=\"token number\">1</span>부터 <span class=\"token number\">10</span>까지의 합을 구하는 매우 간단한 <span class=\"token keyword\">for</span>문 이다<span class=\"token punctuation\">.</span>\n\n이를 재귀함수로 표현하면\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">return</span> <span class=\"token number\">1</span> <span class=\"token comment\">// 종료 조건</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">return</span> n <span class=\"token operator\">+</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 재귀함수</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>보통 코드는 위에서 아래로 읽히지만(본인도 무조건 위에서 아래로 읽힌다고 생각하고 있었어서 재귀함수가 돌아가는 순서가 매우 헷갈렸었다.)</p>\n<p>함수 안에서 함수를 선언해주기 때문에 선언은 단순히 선언으로만 끝나고, 마지막 리턴문(겸 재귀함수의 호출문) 에서 함수가 호출되 다시 처음으로 돌아가는 구조를 갖고있다.</p>\n<p>재귀함수를 사용하는 대표적인 예로 피보나치수열이 있는데, 피보나치수열이란 1 번째항은 1, 2번째항은1, 3번째 항부터는 전전항과 전항을 더한 숫자로 구성되는 수열이다. 코드로는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 피보나치 수열을 저장하는 배열</span>\n  <span class=\"token keyword\">const</span> answer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">100000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    answer<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> answer<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> answer<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> answer<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>하지만 재귀함수는 메모리를 많이 차지하고 성능이 반복문에 비해 느리다는 단점이 있다.(계속해서 함수를 호출하므로 스택의 메모리가 커진다.)</p>\n<p>그러므로 사용해야 할 시점을 명확히 알고 사용하도록 하자.</p>","excerpt":"재귀함수란 함수의 호출결과로 함수를 리턴하는 함수를 말한다. 알고리즘뿐만 아니라 여러가지로 많이 쓰이는 기법이다. 간단한 예를 들어보자. 보통 코드는 위에서 아래로 읽히지만(본인도 무조건 위에서 아래로 읽힌다고 생각하고 있었어서 재귀함수가 돌아가는 순서가 매우 헷갈렸었다.) 함수 안에서 함수를 선언해주기 때문에 선언은 단순히 선언으로만 끝나고, 마지막 리턴문(겸 재귀함수의 호출문) 에서 함수가 호출되 다시 처음으로 돌아가는 구조를 갖고있다. 재귀함수를 사용하는 대표적인 예로 피보나치수열이 있는데, 피보나치수열이란 1 번째항은 1, 2번째항은1, 3번째 항부터는 전전항과 전항을 더한 숫자로 구성되는 수열이다. 코드로는 아래와 같다. 하지만 재귀함수는 메모리를 많이 차지하고 성능이 반복문에 비해 느리다는 단점이 있다.(계속해서 함수를 호출하므로 스택의 메모리가 커진다.) 그러므로 사용해야 할 시점을 명확히 알고 사용하도록 하자.","frontmatter":{"date":"August 26, 2022","title":"재귀함수 찍먹하기","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_25/"}},"next":{"id":"2f6db9ca-1d52-5925-9967-140550d2b1d1","html":"<h3 id=\"ci-continuous-integration\" style=\"position:relative;\"><a href=\"#ci-continuous-integration\" aria-label=\"ci continuous integration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CI (Continuous Integration)</h3>\n<p><img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&#x26;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbGXdIT%2FbtqI9GkH3wP%2F5Qx2zLKYRxsYWLSoS6KH3K%2Fimg.png\" alt=\"\"></p>\n<p>CI는 <strong>Continuous Integration</strong>의 줄임말이다.</p>\n<p>즉, 지속적인 통합이라는 의미! 지속적인 통합이란, 어플리케이션의 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어 공유 레포지토리에 통합히는 것을 의미한다. (가능하다면 하루에 여러번까지)</p>\n<h3 id=\"cd-continuous-delivery--continuous-deployment\" style=\"position:relative;\"><a href=\"#cd-continuous-delivery--continuous-deployment\" aria-label=\"cd continuous delivery  continuous deployment permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CD (Continuous Delivery &#x26; Continuous Deployment)</h3>\n<p>CD는 Continuous Delivery 혹은 Continuous Depolyment 두 용어 모두의 축약어이다. 해석하자면, 지속적인 서비스 제공 혹은 지속적인 배포라는 의미!</p>\n<p>Continuous Delivery는 공유 레포지토리로 자동으로 Release 하는 것,Continuous Deployment는 Production 레벨까지 자동으로 deploy 하는 것을 의미한다. 정리하자면, CI가 새로운 소스코드의 빌드, 테스트, 병합까지를 의미하였는데,CD는 개발자의 변경 사항이 레포지토리를 넘어, 고객의 프로덕션(Production) 환경까지 릴리즈 되는 것을 의미한다.</p>\n<p>CI에서 예로 든 MSA와 같은 환경에서 Agile 방법론이 적용될 경우, 서비스의 사용자는 최대한 빠른 시간 내에 최신 버전의 Production을 제공받을 필요가 있다.이 때, 소프트웨어가 언제든지 신뢰 가능한 수준의 버전을 유지할 수 있도록 support 하는 것이 CD라고 할 수 있쥬.</p>\n<p>이는 서비스의 개발팀과 비즈니스팀(영업, CS팀 등) 간의 커뮤니케이션 부족 문제를 해결해 줌으로써, 배포에 이르기까지의 노력을 최소한으로 단축시켜 준다는 Benefit을 제공한다.</p>","frontmatter":{"date":"August 26, 2022","title":"CI/CD","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_23/"}},"prev":{"id":"a595163c-4a2a-517f-85cd-2306e7a06139","html":"<h3 id=\"token\" style=\"position:relative;\"><a href=\"#token\" aria-label=\"token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Token</h3>\n<p>JSON Web Token, 줄여서 jwt는 서버에서 사용자를 식별할 수 있는 정보를 담아 클라이언트에 내려줄 때 쓰는 토큰이다.\n서버가 한 번 인증한 사용자에게 카드키를 준 거라고 생각하면 쉽다.\n토큰을 받은 클라이언트는 다음에 따로 인증을 하지 않아도 토큰을 이용해 로그인한 상태로 웹에 접근할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code></pre></div>\n<p>참고: <a href=\"https://jwt.io/\">https://jwt.io/</a></p>\n<p>빨간색 부분은 헤더로 어떤 알고리즘이 적용됐는지 등의 정보가 담겨 있다. 넘어가도 된다.\n핑크색 부분은 payload로 실제적인 객체 데이터가 담겨 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"sub\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1234567890\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"John Doe\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"iat\"</span><span class=\"token operator\">:</span> <span class=\"token number\">1516239022</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>토큰을 받고 나서 클라이언트가 서버에 무엇인가 요청을 할 때 인증이 필요한 요청이라면 토큰을 보내고 서버에서는 사용자를 확인할 수 있다.</p>\n<p>또한 토큰이 암호화 되어 있으니 사용자의 생일과 같은 정보를 넣어도 좋고 토큰에 사용자에 관한 충분한 정보를 넣었다면 서버에 별도의 요청을 하지 않아도 된다.\n클라이언트에서 분홍색 부분을 디코드 하려면 jwt-decode 모듈을 쓰자.</p>\n<p>하늘색 부분은 인증과 관련된다.\n만약 누군가가 클라이언트에 저장된 토큰을 가로채 핑크색 사용자 정보를 조작한 뒤 서버에 접근한다 해도 전체적인 값이 달라지면 서버에 저장된 시크릿 키에 의해 하늘색 부분의 토큰도 달라지기 때문에 막힌다. 오직 서버에서만 유효한 토큰을 제공할 수 있다.</p>\n<ol>\n<li>Token 생성하기</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> jwt <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'jsonwebtoken'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> token <span class=\"token operator\">=</span> jwt<span class=\"token punctuation\">.</span><span class=\"token function\">sign</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> \\_id<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'socratone'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'secretKey'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 생성된 token을 클라이언트로 보내준다.</span>\nres<span class=\"token punctuation\">.</span><span class=\"token function\">header</span><span class=\"token punctuation\">(</span><span class=\"token string\">'x-auth-token'</span><span class=\"token punctuation\">,</span> token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">_ ... _</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ol start=\"2\">\n<li>Token을 이용해 인증하기</li>\n</ol>\n<p>미들웨어로 만들어서 쓴다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> jwt <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'jsonwebtoken'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">auth</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> token <span class=\"token operator\">=</span> req<span class=\"token punctuation\">.</span><span class=\"token function\">header</span><span class=\"token punctuation\">(</span><span class=\"token string\">'x-auth-token'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 클라이언트에서 헤더로 보낸 토큰을 받는다.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>token<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">status</span><span class=\"token punctuation\">(</span><span class=\"token number\">401</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'토큰이 없습니다.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> decoded <span class=\"token operator\">=</span> jwt<span class=\"token punctuation\">.</span><span class=\"token function\">verify</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">,</span> <span class=\"token string\">'secretKey'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    req<span class=\"token punctuation\">.</span>user <span class=\"token operator\">=</span> decoded<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 디코딩이 잘 되면 user 객체에 담아 다음으로 넘겨준다.</span>\n    <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">status</span><span class=\"token punctuation\">(</span><span class=\"token number\">400</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'유효하지 않은 토큰입니다.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> auth<span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"xsscross-site-scripting\" style=\"position:relative;\"><a href=\"#xsscross-site-scripting\" aria-label=\"xsscross site scripting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>XSS(Cross Site Scripting)</h3>\n<p>사이트를 교차해서 스크립트를 발생시킴.</p>\n<p>게시판을 포함한 웹에서 자바스크립트같은 스크립트 언어를 삽입해 개발자가 의도하지 않은 기능을 작동시키는것.</p>\n<p>클라이언트측을 대상으로 한 공격</p>\n<p>XSS의 등장 배경에대해 알아보자면 1995년 ‘넷스케이프’ 사에 의해 자바스크립트가 도입된다.\n과거에는 넷스케이프의 점유율이 80퍼센트 이상이었을때가 있었고, 그렇기 때문에 그당시 주류였던 넷스케이프에서\n최초로 자바스크립트를 도입하게 되므로 다른 웹서비스들도 자바스크립트를 채택하게되었다.\n2000년에 이르러 ‘마이스페이스’에서 XSS 공격이 최초로 발견되었다. ‘마이스페이스’는 미국판 싸이월드.. 정도\n2005년에는 악성코드 형태로 발견되었고, 현재까지 다양한 변종들이 등장하게 된다.\n일례로 ‘리그 오브 레전드(LOL)’ 에서도 자바스크립트를 이용한 공격이 등장하였다.\n웹에서 빠질수 없는 언어이기때문에, 없어지지않는 취약점 중에 하나라고 볼 수 있다.</p>\n<p>이 문제에 대한 방어법중 하나는 dompurify 이다.</p>\n<p><code class=\"language-text\">yarn add dompurify</code>\n<code class=\"language-text\">yarn add -D @types/dompurify</code>\n코드에 적용시켜 안정성을 확보할 시간입니다!</p>\n<p>하지만 지금은 발생하지 않지만 이렇게 작성해을 주면 Hydration Issue가 생긴다.</p>\n<p>여기서 하이드레이션은 렌더링 결과물의 컴포넌트를 확인하고 각 컴포넌트의 이벤트들을 실제 DOM에 걸어주는데, 이 경우 SSR 시 렌더링되는 컴포넌트와 CSR 시 렌더링되는 컴포넌트가 있기에 DOM 에서 읽어주는 순서가 꼬이게 되어버린다. 이를 방지하기위해 SSR / CSR 렌더링 컴포넌트를 동일하기 주기 위해 빈값을 넣어주어 해결해 준다.</p>\n<h3 id=\"csrf\" style=\"position:relative;\"><a href=\"#csrf\" aria-label=\"csrf permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CSRF</h3>\n<p>CSRF 공격(Cross Site Request Forgery)은 웹 어플리케이션 취약점 중 하나로 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격이다.</p>\n<p>CSRF를 통해 해커는 희생자의 권한을 도용하여 중요 기능을 실행하는 것이 가능하다. 예를들어, 페이스북에 희생자의 계정으로 광고성 글을 올리는 것이 가능해진다. (물론 페이스북은 CSRF 공격에 대해 잘 대응을 하였겠지만, 이번 글에서 피해 서비스 = 페이스북으로 설명하겠다.)</p>\n<p>조금 더 설명하자면, CSRF는 해커가 사용자의 컴퓨터를 감염시키거나 페이스북 서버를 해킹을 해서 이뤄지는 공격은 아니다. 그래서 CSRF 공격이 이뤄지려면 다음 조건이 만족되어야 한다.</p>\n<p>위조 요청을 전송하는 서비스(페이스북)에 희생자가 로그인 상태\n희생자가 해커가 만든 피싱 사이트에 접속\n언뜻 보면 이 두 조건을 다 만족하기가 어려울 것 같지만 생각처럼 드문 일은 아니다. 예를들어 페이스북, 네이버, 구글 등의 유명 사이트는 보통 PC에서 자동 로그인을 해놓은 경우가 많고 피싱 사이트는 피싱 메일 등을 통해 접속될 수 있다. 또한 희생자가 해커가 만든 피싱 사이트를 하지 않더라도 해커가 XSS 공격을 성공한 정상 사이트를 통해 CSRF 공격이 수행될 수 도 있다.</p>","frontmatter":{"date":"August 26, 2022","title":"token, XSS, CSRF","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_26/"}},"site":{"siteMetadata":{"siteUrl":"https://leedawnn.github.io","comments":{"utterances":{"repo":"leedawnn/leedawnn.github.io"}}}}},"pageContext":{"slug":"/codecamp_blog_25/","nextSlug":"/codecamp_blog_23/","prevSlug":"/codecamp_blog_26/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}