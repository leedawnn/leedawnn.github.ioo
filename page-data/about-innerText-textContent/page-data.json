{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/about-innerText-textContent/",
    "result": {"data":{"cur":{"id":"e94c82d1-4c13-5f60-a35e-a9f0249a49d5","html":"<p>개인적으로 element에 텍스트를 추가하고 싶을 때는 innerText를 사용하는 편이에요. 두 프로퍼티는 어떤 공통점과 차이점을 가지고 있는지 궁금해져서 정리해보려고 합니다 !</p>\n<h3 id=\"공통점-\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%ED%86%B5%EC%A0%90-\" aria-label=\"공통점  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공통점 🍯</h3>\n<ol>\n<li>\n<p><strong>둘 다 텍스트노드를 추가해요.</strong></p>\n<p>텍스트를 추가한다는 공통점이 있어요. 결과 역시 동일해요.</p>\n</li>\n<li>\n<p><strong>해당 element의 텍스트 값을 반환해요.</strong></p>\n<p>즉, 어떤 텍스트를 가지고 있는지 알 수 있어요.</p>\n</li>\n</ol>\n<h3 id=\"차이점-\" style=\"position:relative;\"><a href=\"#%EC%B0%A8%EC%9D%B4%EC%A0%90-\" aria-label=\"차이점  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>차이점 👻</h3>\n<ol>\n<li>\n<p><code class=\"language-text\">textContent</code>는 <code class=\"language-text\">&lt;script></code>와 <code class=\"language-text\">&lt;style></code> 요소를 포함한 모든 요소의 콘텐츠를 가져옵니다. 반면 <code class=\"language-text\">innerText</code>는 “사람이 읽을 수 있는” 요소만 처리해요.</p>\n<p>즉, <code class=\"language-text\">textContent</code>는 모든 텍스트를 그대로 가져오지만, <code class=\"language-text\">innerText</code>는 불필요한 공백을 제거하고 텍스트로 반환하는 차이점이 있어요.</p>\n</li>\n<li>\n<p>textConent가 먼저 만들어졌고, 더 빨리 사용되었다고 해요. 이런 이유로 브라우저 호환성도 좀 더 높습니다. 또한 큰 차이는 아니지만 더 가볍다고 알려져 있어요.</p>\n<p>예를 들어, 아래와 같은 태그가 있다고 가정해볼게요.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style\"><span class=\"token language-css\">\n    <span class=\"token selector\">#source</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> red<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  </span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n  아래에서<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>br</span> <span class=\"token punctuation\">/></span></span>이 글을<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>br</span> <span class=\"token punctuation\">/></span></span>어떻게 인식하는지 살펴보세요.\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span> <span class=\"token special-attr\"><span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value css language-css\"><span class=\"token property\">display</span><span class=\"token punctuation\">:</span>none</span><span class=\"token punctuation\">\"</span></span></span><span class=\"token punctuation\">></span></span>숨겨진 글<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>이 때, innerText와 textContent의 결과는 다릅니다.</p>\n<p><strong>innerText를 사용한 경우</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> msg <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>innerText<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n#source <span class=\"token punctuation\">{</span> color<span class=\"token operator\">:</span> red<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n아래에서이 글을어떻게 인식하는지 살펴보세요<span class=\"token punctuation\">.</span>\n숨겨진 글 <span class=\"token comment\">// 출력 결과</span></code></pre></div>\n<p><strong>textContent를 사용한 경우</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> msg <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>textContent<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n아래에서\n이 글을\n어떻게 인식하는지 살펴보세요<span class=\"token punctuation\">.</span><span class=\"token comment\">// 출력 결과</span></code></pre></div>\n</li>\n</ol>\n<ul>\n<li>\n<p>인용</p>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/HTMLElement/innerText\">https://developer.mozilla.org/ko/docs/Web/API/HTMLElement/innerText</a> > <a href=\"https://developer.mozilla.org/ko/docs/Web/API/Node/textContent\">https://developer.mozilla.org/ko/docs/Web/API/Node/textContent</a></p>\n</blockquote>\n</li>\n</ul>","excerpt":"개인적으로 element에 텍스트를 추가하고 싶을 때는 innerText를 사용하는 편이에요. 두 프로퍼티는 어떤 공통점과 차이점을 가지고 있는지 궁금해져서 정리해보려고 합니다 ! 공통점 🍯 둘 다 텍스트노드를 추가해요. 텍스트를 추가한다는 공통점이 있어요. 결과 역시 동일해요. 해당 element의 텍스트 값을 반환해요. 즉, 어떤 텍스트를 가지고 있는지 알 수 있어요. 차이점 👻 는 와  요소를 포함한 모든 요소의 콘텐츠를 가져옵니다. 반면 는 “사람이 읽을 수 있는” 요소만 처리해요. 즉, 는 모든 텍스트를 그대로 가져오지만, 는 불필요한 공백을 제거하고 텍스트로 반환하는 차이점이 있어요. textConent가 먼저 만들어졌고, 더 빨리 사용되었다고 해요. 이런 이유로 브라우저 호환성도 좀 더 높습니다. 또한 큰 차이는 아니지만 더 가볍다고 알려져 있어요. 예를 들어, 아래와 같은 태그가 있다고 가정해볼게요. 이 때, innerText와 textContent의 결과는 다릅니다…","frontmatter":{"date":"March 16, 2022","title":"innerText vs textContent","categories":"JS","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/about-innerText-textContent/"}},"next":{"id":"d36652d6-8d98-50a3-8eb4-39169d2807ca","html":"<h4 id=\"들어가기에-앞서\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0%EC%97%90-%EC%95%9E%EC%84%9C\" aria-label=\"들어가기에 앞서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가기에 앞서..</h4>\n<p>파이널 프로젝트를 하면서, 싱크업 미팅 때 홈페이지 인덱스 쪽을 SSR로 개발해달라는 기업 측 요구사항이 있어서 공부할 겸 정리를 해보려고 합니다 😃</p>\n<hr>\n<h3 id=\"csr란-무엇인가\" style=\"position:relative;\"><a href=\"#csr%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"csr란 무엇인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CSR란 무엇인가?</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsTAAALEwEAmpwYAAACKElEQVQoz3WTzW4TMRDHUyQucOIBEA/AE/AIRRw4AEIcEC/ADQ4Iqa0E9IDgxgX1RkCopPQCUikVB9KWkiZRoWlC0nx/O8luNomzu17bM4bdDZtSYGTZI1s/W//5j0Pqr0B054rBEk26WR1me1aweSxCE8AbfoCXfWuPI2ltMVr/VBr4m4Ao4Y9LQuo/IVH1bcEE2AL++ewUpo6sDZzG0NFMjqjymk0oV0qlOuZKWqsaTCn1Il6/t5KoUxGomMBlg+3URqU+0y0hAPeJWey7wMeC8XirkWxSpdTt1YPzC++3G2YgbQKPORzq9oBJ7wC7Y57tWYBKt8Q+MVsjhwnYrNK1Ek02KZNwXDOXGGhzC4OTQsKRRAIIQAE4hVsj59qb3JXl7OXXP95mtDvr5YvhzI1ILloZ3lw9nA2nn8fJo8/1Sy8zt1bzV5ezGwXDqyi6cEG3zyzGTj/8emJ+++56+cLS/szc9qkHO8922+eeJkL3t65HcrPh9Mzc1tkn8ZMLX5aSRCklwIMdCSliJlvj78S0BBT7dqxBDzXXo1THjDfpiMnKwNkjbK/j7BGrbwlfyESzAHQk+pZyQC7R4iABuaeQCQRE0q21SHlAR+p3R4X8pT500l3TsAWia9tug+qm4ICJJj3omCOOSvJ49NXau3lKYp7PMIV7Y57Xbd1yYUJdn3zDc5pVMRh1QCnIVdsfNjZYpxh8gGlv+607dQWDHIP+PPoFfsE/AeyhAQOh/9WIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"csr\"\n        title=\"csr\"\n        src=\"/static/f6ea6fffafaa99522805db78258cbfb2/37523/csr.png\"\n        srcset=\"/static/f6ea6fffafaa99522805db78258cbfb2/e9ff0/csr.png 180w,\n/static/f6ea6fffafaa99522805db78258cbfb2/f21e7/csr.png 360w,\n/static/f6ea6fffafaa99522805db78258cbfb2/37523/csr.png 720w,\n/static/f6ea6fffafaa99522805db78258cbfb2/302a4/csr.png 1080w,\n/static/f6ea6fffafaa99522805db78258cbfb2/2cefc/csr.png 1400w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>CSR란 <strong>Client Side Rendering</strong>의 약자로, 클라이언트가 렌더링을 하는 방식을 말합니다.</p>\n<p>우리가 웹사이트에 접속하게 되면, 빈 HTML 파일을 먼저 다운받게 됩니다. 그래서 이 HTML 파일 안에 있는 DOM 요소나 스타일들이 보이게 되죠.\n이 다음 단계부터는 리액트를 예시로 들겠습니다. 리액트는 자바스크립트로 이루어진 커다란 웹 애플리케이션입니다. 그렇기 때문에 자바스크립트 전체가 다운이 완료되어야지 리액트가 실행됩니다. 이후 한마디로 전체 자바스크립트 파일이 다운되어서 실행되기 전까지 우리는 리액트 앱 화면을 볼 수 없다는 말이죠. 🥲</p>\n<p>리액트가 실행되면 리액트 컴포넌트들이 화면에 그려지게 되고 그제서야 화면을 볼 수 있게 되고, 유저가 인터랙션을 할 수 있게 됩니다. 이후 필요한 내용들을 요청하면 서버에서는 필요한 데이터를 JSON으로 보내주고, 클라이언트가 알아서 재구성합니다.</p>\n<h3 id=\"ssr란-무엇인가\" style=\"position:relative;\"><a href=\"#ssr%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"ssr란 무엇인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSR란 무엇인가?</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 71.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsTAAALEwEAmpwYAAACRElEQVQoz41SO2/TUBQ2EwtSZxY2Fn4HA/+gAxULqjrDAKgSbxQECCG6wMgAEglJmwYQgSrQBNqmoWpE48R2EhoaO08/6ji2r++17z0ojz4Agfh0lnvu+b7z5GAINrTDeC0az/LduWwzK1sAENCxP2DMp2wUzMFfIPfwutLPNfo/dj34Qxr2ycinXZtoDjGRPwoyUVA3PZ+OKULXTW2bqkMAICl25vOyhemY/F33srIlqk7d9EYFNSy81bYN1x/WCZGCemdZltTB+/Rc+uSVKK8PvjifsoaF8y27YxPKgDJgDLo2+dZ2yjoaZd5s2glRr+rIRP7Tr+3H2dZa3aJsr2ccMPprW2w4m988Q3VGGbMwdQnlRNWNFvW3ZWOhpG82bc31E6IxsrigKz1c0VGE1yK8JmmoY5NYUXtZUKvDorjZZI27nJkIZY/eWj3xcONeRjl2c20ilD1+P8dd/XLmeeliospd+MTNZk492ridlo9cW+Eupa+ndgbkCK9ORsSZRHUqKoUySk7pn18oTy9WZhLVs6+kWFGLFbXJiDAVk57kWp93etOLlXPz0hvJONjzYE6H2gsoeJjB/mEEgPF41yQAhNnBnrs2aVi4bROHBADgEVIqLRfFZL0lAYCLkCgs88K7llqzHSSUlnjpQ9dQxmSlhwsdB/t0RAZG8iuJcPiuJy8NchNnPRWOxx/47VXA+OP7F/HwDdC3xuRd5HdsYrg+3rvgdt8r1xSkdQZSjLV6bnW7jg2VASgmKvICNvV/3fb/4CdLru/c3uTpkgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ssr\"\n        title=\"ssr\"\n        src=\"/static/bea87025b026608390db455af1123ace/37523/ssr.png\"\n        srcset=\"/static/bea87025b026608390db455af1123ace/e9ff0/ssr.png 180w,\n/static/bea87025b026608390db455af1123ace/f21e7/ssr.png 360w,\n/static/bea87025b026608390db455af1123ace/37523/ssr.png 720w,\n/static/bea87025b026608390db455af1123ace/302a4/ssr.png 1080w,\n/static/bea87025b026608390db455af1123ace/2cefc/ssr.png 1400w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>SSR이란 <strong>Server Side Rendering</strong>의 약자로, 서버에서 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식입니다.</p>\n<p>클라이언트가 요청을 하면 서버에서는 필요한 것들을 이용해 HTML 파일을 만들고, HTML 파일과 동적으로 제어할 수 있는 스크립트를 클라이언트에 보냅니다.</p>\n<h3 id=\"️-요약\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%EC%9A%94%EC%95%BD\" aria-label=\"️ 요약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✍️ 요약</h3>\n<h4 id=\"csr\" style=\"position:relative;\"><a href=\"#csr\" aria-label=\"csr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CSR</h4>\n<ul>\n<li>장점 😃</li>\n</ul>\n<ol>\n<li>필요한 부분만 요청해서 받아오기 때문에 SSR보다 상대적으로 빠릅니다.</li>\n<li>요청시에 필요한 부분만 데이터를 받아오기 때문에 서버에 부담이 적습니다.</li>\n</ol>\n<ul>\n<li>단점 🥲</li>\n</ul>\n<ol>\n<li>처음에 모든 파일을 받아와야하기 때문에 SSR보다 초기 속도가 느립니다.</li>\n<li>SEO에 취약합니다.</li>\n</ol>\n<h4 id=\"ssr\" style=\"position:relative;\"><a href=\"#ssr\" aria-label=\"ssr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSR</h4>\n<ul>\n<li>장점 😃</li>\n</ul>\n<ol>\n<li>CSR을 사용했을 때보다 페이지 로딩이 빠르기 때문에 사용자가 빠르게 화면을 볼 수 있습니다.</li>\n<li>SEO에 효율적입니다.</li>\n<li>정적인 사이트에 사용하기 좋습니다.</li>\n</ol>\n<ul>\n<li>단점 🥲</li>\n</ul>\n<ol>\n<li>페이지를 요청할때마다 필요한 부분만 바꿔서 보여주는 것이 아닌 새로운 페이지를 보여주기 때문에 화면이 깜빡이는 현상이 있습니다.</li>\n<li>서버에 계속 요청해야하기 때문에 서버 부하가 커집니다.</li>\n<li>동적으로 데이터를 처리하는 파일을 받아오는 것이 느리면, 사용자가 아무리 클릭을 해도 반응을 하지 않는 경우가 생기기도 합니다.</li>\n</ol>\n<blockquote>\n<p>사진 출처 : <a href=\"https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8\">https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8</a> 인용 : <a href=\"https://d2.naver.com/helloworld/7804182\">https://d2.naver.com/helloworld/7804182</a></p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<ul>\n<li><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0%EC%97%90-%EC%95%9E%EC%84%9C\">들어가기에 앞서..</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#csr%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">CSR란 무엇인가?</a></p>\n</li>\n<li>\n<p><a href=\"#ssr%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">SSR란 무엇인가?</a></p>\n</li>\n<li>\n<p><a href=\"#%EF%B8%8F-%EC%9A%94%EC%95%BD\">✍️ 요약</a></p>\n<ul>\n<li><a href=\"#csr\">CSR</a></li>\n<li><a href=\"#ssr\">SSR</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 09, 2022","title":"CSR, SSR이 뭐예요?","categories":"web","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/whta-is-CRS-SSR/"}},"prev":{"id":"b05632b8-84cf-5574-b399-2858b0e1bcc1","html":"<p>오늘은 BEM 방법론에 대해 얘기해보려해요 😃<br>\nBEM 공식문서를 보면, BEM(Block, Element, Modifier)이란 웹 개발에 대한 컴포넌트 기반 접근법이라고 나와있어요.\n말이 어렵지만 유지보수를 위한 css 클래스네임에 대한 고민? 이라고 생각하면 될 것 같아요.</p>\n<h2 id=\"1-introduction\" style=\"position:relative;\"><a href=\"#1-introduction\" aria-label=\"1 introduction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Introduction</h2>\n<p>소규모 사이트에서 스타일에 대해 코드를 짤 때 어떻게 구성할 지에 대해서 신경쓰지 않는 것은 보통 큰 문제가 되지 않아요.\n하지만, 규모가 크고 복잡한 프로젝트의 경우 다음과 같은 3가지 이유로 아주 중요해집니다.</p>\n<ol>\n<li>\n<p>코드 작성 시간에 영향을 끼친다.</p>\n</li>\n<li>\n<p>써야하는 코드의 양에 영향을 끼친다.</p>\n</li>\n<li>\n<p>브라우저가 로딩해야하는 양에 영향을 끼친다.</p>\n<p>또한 팀과 협업해야 할 때, 그리고 좋은 퍼포먼스가 필수적일 때 특히 중요해요. 레거시 코드와 함께 긴 기간 진행되는 프로젝트들에도 역시 중요합니다.</p>\n</li>\n</ol>\n<h2 id=\"2-methodologies\" style=\"position:relative;\"><a href=\"#2-methodologies\" aria-label=\"2 methodologies permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Methodologies</h2>\n<p>CSS 설치 공간을 줄이고, 개발자 간의 협력을 구성하며 대규모 CSS 코드베이스를 유지하는 것을 목표로 하는 다양한 방법론들이 있어요.</p>\n<ul>\n<li>\n<p>OOCSS\n: Separating container and content with CSS “objects”</p>\n</li>\n<li>\n<p>SMACSS\n: Style-guide to write your CSS with five categories for CSS rules</p>\n</li>\n<li>\n<p>SUITCSS\n: Structured class names and meaningful hyphens</p>\n</li>\n<li>\n<p>Atomic\n: Breaking down styles into atomic, or indivisible, pieces</p>\n</li>\n</ul>\n<h2 id=\"3-bem을-왜-사용해야되나요\" style=\"position:relative;\"><a href=\"#3-bem%EC%9D%84-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%EB%90%98%EB%82%98%EC%9A%94\" aria-label=\"3 bem을 왜 사용해야되나요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. BEM을 왜 사용해야되나요?</h2>\n<p>BEM은 다수의 개발자가 CSS와 HTML 모듈을 병렬로 구축하고 있을 때 가장 효과적이에요. 대규모 팀에서 발생하는 실수나 버그를 방지하는 데 도움이 되죠. 네이밍 컨벤션이 기술적이고 예측 가능하기 때문에 확장성이 우수해요. BEM은 큰 팀뿐만 아니라 큰 팀에서도 잘 작동합니다.</p>\n<blockquote>\n<p>내가 다른 방법론들을 쓰지 않고 BEM을 고른 이유는 다음과 같다. BEM은 다른 방법론에 비해 혼란을 덜 야기한다. (i.e. SMACSS) 하지만 여전히 알아차리기 쉬운 용어를 사용하여 우리가 원하는 좋은 아키텍처를 제공한다. (i.e. OOCSS)</p>\n</blockquote>\n<p>Mark McDonnell, Maintainable CSS with BEM</p>\n<h2 id=\"4-bem의-기본-구조\" style=\"position:relative;\"><a href=\"#4-bem%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0\" aria-label=\"4 bem의 기본 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. BEM의 기본 구조</h2>\n<p>BEM은 Blcok, Element, Modifier를 뜻해요. 이 3가지로 구성된 이름을 짓는 거죠! 그리고 각각 __와 —로 구분합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token selector\">.header__navigation--navi-text</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> red<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드에서 <code class=\"language-text\">header</code>는 Block, <code class=\"language-text\">naviagtion</code>은 Element, <code class=\"language-text\">navi-text</code>는 Modifier가 됩니다.</p>\n<p>BEM은 기본적으로 ID를 사용하지 않으며, <strong>class</strong>만을 사용해요.<br>\n또, ‘어떻게 보이는가’가 아니라 ’<strong>어떤 목적인가</strong>‘에 따라 이름을 짓습니다.<br>\n예를 들어, 에러 메시지를 띄우는 p 태그에게는 .red가 아닌, .error라는 이름을 줘야하죠.\n이름을 연결할 때는 block-name과 같이 하이픈 하나만 써서 연결합니다.</p>\n<h2 id=\"5-block-element-modifier\" style=\"position:relative;\"><a href=\"#5-block-element-modifier\" aria-label=\"5 block element modifier permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Block, Element, Modifier</h2>\n<p>Block은 재사용할 수 있는 기능적으로 독립된 페이지 컴포넌트예요.</p>\n<p>Block은 다음과 같은 특징을 가져요.</p>\n<ol>\n<li>중첩 기능</li>\n<li>임의 배치</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABsUlEQVQoz3WSXW/TMBiF8///BRISV1zBJASa6LaKqoVu6/q50A+a5stJGsd27NiO/b4IFYQmwaPn9uhcnBPgBcAXANI8r0hC0sg5h/8heJkB0BZcDymDsIS2Q6aAtlAKqCW2Go3TpitIXJe5Ejz4XdtZpPKXWYuFxhHBZ4atx8oi7dEDGodMIZUupW2Ryu7c2z4AbW1Wm4Iba/2eycE2H87IdHWaLI+fF8ngiQzXDVEtOu+dAw8WKX1UeYg9Biap4u/zKrpvkll2PMy+zkefhg+DyWY02y93D5vNq6v3b25vp6IznTiScdx8i9Qwrm9MngWm4nl4vb57e7r/kKXjpRBTxm+YHIvuHdcfhQ4JiUjmABtYrZ6Gh+XGCMf6lMnnoM9oHYVN/MDIpjt9kcW25bzlVCtRSTXn8micBECPDPaPi6vrwWsi1qWc2IwE6D2EhU8a4No3SpV5ctimP3Yto+g9OldyMd/vijgq4lMnUivS7hz5nKGFAHsPpIHeeaVBGeAaa4lNh1TCuYWzxJLZU27SyqQVMIsSUMPfndm53IeL6BAedqumqS57//MV8MdL+Cf0WDAlc2rL1AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"bem block\"\n        title=\"bem block\"\n        src=\"/static/149b012a4cacff1b49676ca3037a6dde/37523/bem_block.png\"\n        srcset=\"/static/149b012a4cacff1b49676ca3037a6dde/e9ff0/bem_block.png 180w,\n/static/149b012a4cacff1b49676ca3037a6dde/f21e7/bem_block.png 360w,\n/static/149b012a4cacff1b49676ca3037a6dde/37523/bem_block.png 720w,\n/static/149b012a4cacff1b49676ca3037a6dde/20c85/bem_block.png 999w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>👩‍🔧 인용<br>\n<a href=\"http://getbem.com/introduction/\">http://getbem.com/introduction/</a><br>\n<a href=\"https://en.bem.info/methodology/quick-start/\">https://en.bem.info/methodology/quick-start/</a></p>\n</blockquote>","frontmatter":{"date":"March 24, 2022","title":"BEM 방법론","categories":"css","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/what-is-BEM/"}},"site":{"siteMetadata":{"siteUrl":"https://leedawnn.github.io","comments":{"utterances":{"repo":"leedawnn/leedawnn.github.io"}}}}},"pageContext":{"slug":"/about-innerText-textContent/","nextSlug":"/whta-is-CRS-SSR/","prevSlug":"/what-is-BEM/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}