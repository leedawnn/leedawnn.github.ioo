{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/codecamp_blog_7/",
    "result": {"data":{"cur":{"id":"0786dbcf-d3c8-56cf-b5dc-774ad84d8acb","html":"<h3 id=\"정규표현식이란\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D%EC%9D%B4%EB%9E%80\" aria-label=\"정규표현식이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정규표현식이란?</h3>\n<ol>\n<li>\n<p>일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어이다.</p>\n</li>\n<li>\n<p>정규 표현식은 문자열을 대상으로 <strong>패턴 매칭 기능</strong>을 제공한다. 패턴 매칭 기능이란 특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환할 수 있는 기능을 말한다.</p>\n</li>\n</ol>\n<p>예를 들어, 회원가입 폼에서 사용자로부터 입력받은 핸드폰 번호가 유효한 전화번호인지 체크하는 경우를 생각해 보자. 핸드폰 번호는 “숫자 3개 + ‘-’ + 숫자 4개 + ‘-’ + 숫자 4개”라는 일정한 패턴이 있다. 이 핸드폰 번호 패턴을 다음과 같이 정규 표현식으로 정의하고, 사용자로부터 입력받은 문자열이 이 핸드폰 번호 패턴에 매칭하는지 체크할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 사용자로부터 입력받은 핸드폰 번호</span>\n<span class=\"token keyword\">const</span> phone <span class=\"token operator\">=</span> <span class=\"token string\">'010-1234-567팔'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 정규 표현식 리터럴로 핸드폰 번호 패턴을 정의</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^\\d{3}-\\d{4}-\\d{4}$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^\\d{3}-\\d{3,4}-\\d{4}$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// phone이 핸드폰 번호 패턴에 매칭하는지 테스트</span>\nregExp<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>phone<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code></pre></div>\n<h3 id=\"정규-표현식의-구성\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D%EC%9D%98-%EA%B5%AC%EC%84%B1\" aria-label=\"정규 표현식의 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정규 표현식의 구성</h3>\n<ol>\n<li>\n<p>정규 표현식 리터럴은 패턴과 플래그로 구성된다.</p>\n<ul>\n<li>pattern : 정규 표현식의 패턴</li>\n<li>flags: 정규 표현식의 플래그(g, i, m, u, y) >> 표 그리기</li>\n</ul>\n</li>\n<li>\n<p>RegExp 메서드</p>\n<ul>\n<li><strong>RegExp.prototype.exec</strong></li>\n</ul>\n<p>exec 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환한다. 매칭 결과가 없는 경우 null을 반환한다. exec 메서드는 g 플래그를 지정해도 첫번째 매칭 결과만 반환하므로 주의할 것 !</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token string\">'Is this all there is?'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">is</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">;</span>\n\nregExp<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ['is', index: 5, input: 'Is this all there is?', groups: undefined]</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token string\">'Is this all there is?'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">is</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">gi</span></span><span class=\"token punctuation\">;</span>\n\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regExp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ['Is', 'is', 'is']</span></code></pre></div>\n<ul>\n<li>\n<p><strong>RegExp.prototype.test</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">test 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 불리언 값으로반환한다.</code></pre></div>\n</li>\n<li>\n<p><strong>String.prototype.match</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">match 메서드는 대상 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 배열로 반환한다. exec 메서드와는 달리 match 메서드는 g 플래그가 지정되면 모든 매칭 결과를 배열로 반환한다.</code></pre></div>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token string\">'Is this all there is?'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">is</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">;</span>\n\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regExp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ['is', index: 5, input: 'Is this all there is?', groups: undefined]</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token string\">'Is this all there is?'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">is</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regExp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ['is', 'is']</span></code></pre></div>\n</li>\n</ol>\n<h3 id=\"패턴\" style=\"position:relative;\"><a href=\"#%ED%8C%A8%ED%84%B4\" aria-label=\"패턴 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>패턴</h3>\n<ul>\n<li>\n<p>임의의 문자열 검색\n.은 임의의 문자 한 개를 의미한다. 문자의 내용은 상관없다. 아래 코드를 보면 .을 3개 연속하여 패턴을 생성했으므로 문자의 내용과 상관없이 3자리 문자열과 매치한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token string\">'Is this all there is?'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">...</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regExp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ['Is ', 'thi', 's a', 'll ', 'the', 're ', 'is?']</span></code></pre></div>\n</li>\n<li>\n<p>반복 검색\n{m,n}은 앞의 패턴이(아래 코드의 경우 A)이 최소 m번, 최대 n번 반복되는 문자열을 의미한다. 콤마 뒤에 공백이 있으면 정상 동작하지 않으므로 주의!</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token string\">'A AA B BB Aa Bb AAA'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> regExp <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">A{1,2}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\ntarget<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regExp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ['A', 'AA', 'A', 'AA', 'A']</span></code></pre></div>\n</li>\n</ul>","excerpt":"정규표현식이란? 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어이다. 정규 표현식은 문자열을 대상으로 패턴 매칭 기능을 제공한다. 패턴 매칭 기능이란 특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환할 수 있는 기능을 말한다. 예를 들어, 회원가입 폼에서 사용자로부터 입력받은 핸드폰 번호가 유효한 전화번호인지 체크하는 경우를 생각해 보자. 핸드폰 번호는 “숫자 3개 + ‘-’ + 숫자 4개 + ‘-’ + 숫자 4개”라는 일정한 패턴이 있다. 이 핸드폰 번호 패턴을 다음과 같이 정규 표현식으로 정의하고, 사용자로부터 입력받은 문자열이 이 핸드폰 번호 패턴에 매칭하는지 체크할 수 있다. 정규 표현식의 구성 정규 표현식 리터럴은 패턴과 플래그로 구성된다. pattern : 정규 표현식의 패턴 flags: 정규 표현식의 플래그(g, i, m, u, y) >> 표 그리기 RegExp 메서드 RegExp.prototype.exec exec 메서드는 인수로 전달받은…","frontmatter":{"date":"August 26, 2022","title":"정규 표현식","categories":"RegExp","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_7/"}},"next":{"id":"a66972cb-699b-516b-9d0c-d2fc8f26e4b6","html":"<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> aaa <span class=\"token operator\">=</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">qqq</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token operator\">></span> aaa<span class=\"token punctuation\">.</span><span class=\"token function\">qqq</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이런 부분을 화살표 함수를 사용해주면, bind() 필요없이 this 값은 렉시컬 this가 된다. (예측한대로)</p>\n<h3 id=\"컴포넌트-생명주기\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0\" aria-label=\"컴포넌트 생명주기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트 생명주기</h3>\n<ol>\n<li>그리기(render)</li>\n<li>그리고 난 뒤(componentDidMount)</li>\n<li>그리고 난 뒤 변경됐을 때(componentDidUpdate)</li>\n<li>그리고 난 뒤 사라질 때(componentWillIUnmount)</li>\n</ol>\n<h3 id=\"useeffect\" style=\"position:relative;\"><a href=\"#useeffect\" aria-label=\"useeffect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect</h3>\n<p>위의 모든 내용은 <code class=\"language-text\">useEffect</code> 하나로 줄일 수 있다! useEffect는 모든 렌더링이 끝나고 실행된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// componentDidMount</span>\n<span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'그려지고 나서 실행!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 의존성 배열(dependency array) 안에 있는 값이 바뀌면 실행되는 것을 useEffect라고 함.</span>\n\n<span class=\"token comment\">// componentDidUpdate : 완전히 동일하지는 않음. 변경되면 실행한다는 점을 동일하나, 얘는 맨 처음에도 실행됨.</span>\n<span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'변경되고 나서 실행!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 얘는 의존성 배열이 없기 때문에 처음에도 실행됨.</span>\n\n<span class=\"token comment\">// componentWillIUnmount</span>\n<span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사라질 때 실행!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>하나로 합칠 수도 있음!</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'그려지고 나서 실행!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'사라질 때 실행!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 이렇게 쓰면 count 변수가 변할 때마다 실행.</span></code></pre></div>\n<h3 id=\"useeffect의-잘못된-사용-예제\" style=\"position:relative;\"><a href=\"#useeffect%EC%9D%98-%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%A0%9C\" aria-label=\"useeffect의 잘못된 사용 예제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect의 잘못된 사용 예제</h3>\n<ol>\n<li>추가 렌더링 발생(setState)</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prev</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> prev <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ol>\n<li>무한 루프</li>\n</ol>\n<p>useEffect 내에서 setState를 사용하게 되면 불필요한 리렌더나 무한루프를 일으키게 되고 성능 면에서 비효율적이게 된다.</p>\n<h3 id=\"useeffect-사용-시-주의사항\" style=\"position:relative;\"><a href=\"#useeffect-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD\" aria-label=\"useeffect 사용 시 주의사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect 사용 시 주의사항</h3>\n<p><strong>useEffect 안에서 setState의 사용</strong></p>\n<p>⇒ <em>정말 필요한 경우가 아니라면 지양해야한다.</em></p>\n<p>컴포넌트가 마운트된 이후에 setState를 적용하게 되면,</p>\n<ol>\n<li><strong>state가 변경되고,</strong></li>\n<li><strong>변경된 state로 컴포넌트가 리렌더된다.</strong></li>\n</ol>\n<p>즉, useEffect 내에서 setState를 사용하게 되면 불필요한 리렌더나 무한루프를 일으키게 되어 성능면에서 비효율적이게 된다.</p>\n<h3 id=\"ref\" style=\"position:relative;\"><a href=\"#ref\" aria-label=\"ref permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ref</h3>\n<p><strong>사용하는 이유</strong></p>\n<p>id는 유일해야한다. 하지만 컴포넌트 재사용을 한다면 중복될 가능성이 있다. ref를 사용하면, 이를 방지할 수 있다. ref는 전역적으로 작동하지 않고 컴포넌트 내부에서만 작동하기 때문이다.</p>\n<p><strong>언제 사용해야하나?</strong></p>\n<p>DOM을 꼭 직접적으로 건드려야할 때 사용한다.</p>\n<ul>\n<li>특정 input에 포커스 주기</li>\n<li>스크롤 박스 조작하기</li>\n<li>Canvas 요소에 그림 그리기 등</li>\n</ul>\n<p>위와 같은 경우에는 어쩔 수 없이 DOM에 직접 접근을 해야한다.\n리액트 공식문서를 보면, <code class=\"language-text\">선언적으로 해결될 수 있는 문제에서는 ref 사용을 지양해야한다.</code> 라고 명시 되어있다.</p>\n<p><strong>useRef()</strong></p>\n<p>hook을 사용해야하는 함수형 컴포넌트 방식에서는 useRef()를 사용해야 엘리먼트에 ref를 지정할 수 있다.</p>\n<p><strong>Ref(referrence)의 특징</strong></p>\n<ol>\n<li>컴포넌트 리렌더링이 되더라도 레퍼런스의 값은 유지된다.</li>\n<li>레퍼런스 값의 업데이트는 컴포넌트 리렌더링을 트리거하지 않는다.</li>\n</ol>\n<p><strong>Ref와 state의 차이</strong></p>\n<ol>\n<li>state의 변화는 컴포넌트 리렌더링을 트리거하지만 ref는 아니다.</li>\n<li>상태 업데이트는 비동기적이며 렌더링된 후 업데이트된 값을 사용할 수 있지만, 참조는 동기적이며 업데이트된 값은 바로 사용할 수 있다.</li>\n</ol>","frontmatter":{"date":"August 26, 2022","title":"useEffect, useRef","categories":"react","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_6/"}},"prev":{"id":"6cd52fba-d645-508a-b1ca-9649a89144ef","html":"<h3 id=\"optimistic-ui\" style=\"position:relative;\"><a href=\"#optimistic-ui\" aria-label=\"optimistic ui permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optimistic-UI</h3>\n<p>낙관적 UI라고도 한다. 보통 mutation을 날리고 응답을 받을 때까지 기다려야한다. 하지만 그렇게 하지 않고 바로 사용자에게 UI가 보여지는 것처럼 속이는 것을 Optimistic UI라고 한다.</p>\n<ol>\n<li>성공 확률이 99%인 요청에 적용 2. 혹시 실패하더라도, 큰 영향이 없는 요청에 적용한다.\n예를 들어, 결제에 달아놓으면 큰일남 ㅎ</li>\n</ol>\n<p>게시판 좋아요 기능에 **<code class=\"language-text\">Optimistic-UI</code>**를 적용한다고 해보자.</p>\n<ol>\n<li>브라우저에서 백엔드로 API를 요청한다.</li>\n<li>브라우저에서 useQuery를 날리면 바로 백엔드로 가는 게 아니라 apolloCache를 먼저 확인한다. (cache-first가 default여서)</li>\n<li>캐시값을 받아오는 걸 기다리지 않고 바로 화면에서 +1,, (<strong>Optimisic-UI</strong>)</li>\n<li>cache 확인하고 백엔드로 api 넘어가서 DB에서 데이터를 찾아, 좋아요 +1 올려줌</li>\n<li>apolloCashe를 백엔드에서 받아온 데이터 값으로 덮어씌운다.</li>\n</ol>\n<h3 id=\"scraping-crawling\" style=\"position:relative;\"><a href=\"#scraping-crawling\" aria-label=\"scraping crawling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scraping, Crawling</h3>\n<ul>\n<li>Scraping : html 코드 긁어오기 (한번만)\n<a href=\"https://www.npmjs.com/package/cheerio\">cheerio</a></li>\n<li>Crawling : html 코드 긁어오기 (정기적으로)\n<a href=\"https://www.npmjs.com/package/puppeteer\">puppeteer</a></li>\n</ul>\n<p><strong>API 요청하는 방법(REST API endpoint)</strong></p>\n<ol>\n<li>브라우저(받은 reponse가 html이면 해석해서 렌더링하는 능력이 있음) - 얘도 GET 요청</li>\n<li>postman</li>\n<li>terminal curl ~</li>\n</ol>\n<p>스크랩핑을 할 때 <strong>브라우저</strong>에서는 <code class=\"language-text\">CORS 정책</code>때문에 막힐 수 있음.</p>\n<p><strong>CORS</strong></p>\n<ul>\n<li>모바일</li>\n<li>백엔드에서 우회해서 요청하는 방법(<strong>proxy server</strong>)</li>\n</ul>\n<h3 id=\"ssr이-필요한-상황\" style=\"position:relative;\"><a href=\"#ssr%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%83%81%ED%99%A9\" aria-label=\"ssr이 필요한 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSR이 필요한 상황</h3>\n<p>중고마켓에서는 각 상품에 대한 og를 하드코딩할 수가 없다.(동적 페이지)</p>\n<p>⇒ <code class=\"language-text\">**useQuery**</code>로 받아와야함. 하지만, 이렇게 만들면 초기 렌더링을 했을 때는 백엔드 요청을 하지 않기 때문에 메타태그가 비어있다.</p>\n<p>따라서, html을 브라우저에 보내주기 전에 먼저 프론트엔드 서버에서 로직을 실행할 수 있게 한다.(axios, useQuery, useMutation 등) ⇒ <code class=\"language-text\">**getServerSideProps()**</code></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/df65986a-e73f-4984-8b01-29acb0f95d70/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-18_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.14.50.png\" alt=\"스크린샷 2022-08-18 오후 1.14.50.png\"></p>\n<p>서버 사이드 렌더링이 필요한 이유 중 **검색 엔진 최적화(SEO)**가 가장 많이 언급된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useMutation<span class=\"token punctuation\">,</span>gql<span class=\"token punctuation\">,</span>useQuery <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"@apollo/client\"</span>\n\n<span class=\"token comment\">//좋아요 갯수 가지고 오는 api _ 게시글 조회 api에서 좋아요 갯수만 뽑아 옵니다.</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">FETCH_BOARD</span> <span class=\"token operator\">=</span> gql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n\tquery fetchBoard($boardId: ID!){\n\t\tfetchBoard(boardId: $boardId){\n\t\t\t_id\n\t\t\tlikeCount\n\t\t}\n\t}\n</span><span class=\"token template-punctuation string\">`</span></span>\n\n<span class=\"token comment\">//좋아요 카운트 올리는 api</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">LIKE_BOARD</span> <span class=\"token operator\">=</span> gql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n\tmutation likeBoard($boardId:ID!){\n\t\tlikeBoard(boardId:$boardId)\n\t}\n</span><span class=\"token template-punctuation string\">`</span></span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>likeBoard<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useMutation</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LIKE_BOARD</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useQuery</span><span class=\"token punctuation\">(</span><span class=\"token constant\">FETCH_BOARD</span><span class=\"token punctuation\">,</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"token punctuation\">{</span>variables <span class=\"token operator\">:</span><span class=\"token punctuation\">{</span>boardId <span class=\"token operator\">:</span> <span class=\"token string\">\"게시글 아이디 넣어주세요!\"</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onClickOptimisticUI</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">//likeBoard 뮤테이션 함수를 실행하겠습니다.</span>\n\t\t<span class=\"token function\">likeBoard</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n\t\t\tvariables <span class=\"token operator\">:</span><span class=\"token punctuation\">{</span>\n\t\t\t\tboardId <span class=\"token operator\">:</span> <span class=\"token string\">\"게시글 아이디 넣어주세요!\"</span>\n\t\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n\t\t<span class=\"token comment\">// 응답을 받고난 후 받아온 응답을 다시 fetch 해줍니다. -> 느리고 효율적이지 못합니다.(백엔드에 요청을 한번더 해야하고 받아올때 까지 기다려야 합니다.)</span>\n\t\t<span class=\"token comment\">//refetchQueries: [</span>\n\t\t<span class=\"token comment\">//\t{</span>\n\t\t<span class=\"token comment\">//\t\tquery: FETCH_BOARD,</span>\n\t\t<span class=\"token comment\">//\t\tvariables : {\tboardId : \"//게시글 아이디 넣어주세요!\" }</span>\n\t\t<span class=\"token comment\">//\t}</span>\n\t\t<span class=\"token comment\">// ]</span>\n\n\t\t<span class=\"token operator\">**</span><span class=\"token comment\">//옵티미스틱 UI -> 캐시를 바꾸고 캐시값을 받아오는걸 기다리지 않고 바로 바꿔줍니다.**</span>\n\t\t<span class=\"token operator\">**</span>optimisticResponse<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n\t\t\tlikeBoard <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>data<span class=\"token operator\">?.</span>fetchBoard<span class=\"token punctuation\">.</span>likeCount <span class=\"token operator\">||</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token operator\">**</span>\n\t\t<span class=\"token operator\">**</span><span class=\"token comment\">// apollo 캐시를 직접 수정을 할 수 있었습니다.(백엔드 캐시가 아닙니다.) -> 느리지만 효율적입니다. (백엔드에 요청은 안하지만, 받아올때까지 기다려줘야 합니다.)</span>\n\t\t\t<span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cache<span class=\"token punctuation\">,</span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token comment\">// 이전 시간에는 modify를 사용했지만, 오늘은 writeQuery를 사용해보겠습니다.</span>\n\t\t\t\tcache<span class=\"token punctuation\">.</span><span class=\"token function\">writeQuery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n\t\t\t\t\tquery <span class=\"token operator\">:</span> <span class=\"token constant\">FETCH_BOARD</span><span class=\"token punctuation\">,</span>\n\t\t\t\t\tvariables <span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>boardId<span class=\"token operator\">:</span><span class=\"token string\">'게시글 아이디 넣어주세요!'</span><span class=\"token punctuation\">}</span>\n\t\t\t\t\t<span class=\"token comment\">//어떻게 수정할 것인지는 아래에 적어줍니다.</span>\n\t\t\t\t\tdata<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t\t\tfetchBoard<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t\t\t\t_id <span class=\"token operator\">:</span> <span class=\"token string\">'게시글 아이디 넣어주세요!'</span><span class=\"token punctuation\">,</span>\n\t\t\t\t\t\t\t__typename <span class=\"token operator\">:</span> <span class=\"token string\">\"Board\"</span>\n\t\t\t\t\t\t\tlikeCount<span class=\"token operator\">:</span> data<span class=\"token operator\">?.</span>likeBoard\n\t\t\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">}</span><span class=\"token operator\">**</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>\n\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">옵티미스틱 UI</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">현재카운트(좋아요):</span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">.</span>fetchBoard<span class=\"token punctuation\">.</span>likeCount<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>onClickOptimisticUI<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">좋아요 올리기!!</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n\t<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"date":"August 26, 2022","title":"Optimistic UI","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_9/"}},"site":{"siteMetadata":{"siteUrl":"https://leedawnn.github.io","comments":{"utterances":{"repo":"leedawnn/leedawnn.github.io"}}}}},"pageContext":{"slug":"/codecamp_blog_7/","nextSlug":"/codecamp_blog_6/","prevSlug":"/codecamp_blog_9/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}