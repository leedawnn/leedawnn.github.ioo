{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/codecamp_blog_13/",
    "result": {"data":{"cur":{"id":"07b01823-a43f-5572-aa64-4049cf2c60e9","html":"<p><strong>SPA(Single Page Application)</strong></p>\n<ul>\n<li><code class=\"language-text\">router를 이용해서 페이지를 이동하는 것과 같은 방식을 채택하는 웹 서비스를 SPA</code>라고 한다.</li>\n<li>SPA에서는 서비스에 처음 접속할 때 모든 페이지의 데이터를 다 받아온다.</li>\n<li>그려져있는 해당 페이지를 브라우저에 렌더링한다(re-rendering). ex) React\n<ul>\n<li>백엔드에서 받아오는 게 아니라 그려져 있는 페이지를 이동시키면서 화면에 띄워줌.</li>\n</ul>\n</li>\n<li>SPA의 경우 최초 로딩에는 시간이 다소 걸릴 수 있으나 페이지를 이동할 때 걸리는 시간이 MPA에 비하여 압도적으로 짧다.</li>\n</ul>\n<h4 id=\"-spa-장점\" style=\"position:relative;\"><a href=\"#-spa-%EC%9E%A5%EC%A0%90\" aria-label=\" spa 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👍 SPA 장점</h4>\n<ul>\n<li>자연스러운 사용자 경험 (UX)</li>\n<li>전체 페이지를 업데이트 할 필요가 없기 때문에 빠르고 ‘깜빡’ 거림이 없다.</li>\n<li>필요한 리소스만 부분적으로 로딩 (성능)</li>\n<li>SPA의 Application은 서버에게 정적리소스를 한 번만 요청한다. 그리고 받은 데이터는 전부 저장해놓는다. (캐시=Cache)</li>\n<li>서버의 템플릿 연산을 클라이언트로 분산 (성능)</li>\n<li>컴포넌트별 개발 용이 (생산성)</li>\n<li>모바일 앱 개발을 염두에 둔다면 동일한 API를 사용하도록 설계 가능 (생산성)</li>\n</ul>\n<h4 id=\"-spa-단점\" style=\"position:relative;\"><a href=\"#-spa-%EB%8B%A8%EC%A0%90\" aria-label=\" spa 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👎 SPA 단점</h4>\n<ul>\n<li>JavaScript 파일을 번들링해서 한 번에 받기 때문에 초기 구동 속도가 느리다. (Webpack의 code splitting으로 해결 가능)</li>\n<li>검색엔진최적화(SEO)가 어려움 (SSR로 해결 가능)</li>\n<li>보안 이슈 (프론트엔드에 비즈니스 로직 최소화)</li>\n<li>SSR에서는 사용자에 대한 정보를 서버측에서 세션으로 관리를 하지만 CSR 방식에서는 클라이언트측의 쿠키말고는 사용자에 대한 정보를 저장할 공간이 마땅치 않다.</li>\n</ul>\n<p><strong>MPA(Mutiple Page Application)</strong></p>\n<ul>\n<li><code class=\"language-text\">a 태그를 이용해서 페이지를 이동하는 것과 같은 방식을 채택하는 웹 서비스</code>를 MPA라고 한다.</li>\n<li>MPA에서는 서로 다른 url을 가진 페이지들은 각각 독립적으로 존재한다.</li>\n<li>따라서, 프론트엔드 서버에서 프리렌더링 후 브라우저로 html, css, js를 보내주는 작업을 매 페이지 이동마다 거치게 된다.</li>\n<li>MPA의 경우 페이지 이동 시마다 서버에 요청해서 데이터를 받아와야 하기 때문에 성능은 좋지 않다.</li>\n</ul>\n<h4 id=\"-mpa-장점\" style=\"position:relative;\"><a href=\"#-mpa-%EC%9E%A5%EC%A0%90\" aria-label=\" mpa 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👍 MPA 장점</h4>\n<ul>\n<li>SEO 관점에서 유리하다.</li>\n<li>MPA는 완성된 형태의 HTML 파일을 서버로부터 전달받는다.\n<ul>\n<li>따라서 검색엔진이 페이지를 크롤링하기에 적합하다.</li>\n</ul>\n</li>\n<li>첫 로딩 매우 짧다(서버에서 이미 렌더링해 가져오기 때문).\n<ul>\n<li>그러나, 클라이언트가 JS 파일을 모두 다운로드하고 적용하기전 까지는 각각의 기능은 동작하지 않는다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"-mpa-단점\" style=\"position:relative;\"><a href=\"#-mpa-%EB%8B%A8%EC%A0%90\" aria-label=\" mpa 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👎 MPA 단점</h4>\n<ul>\n<li>새로운 페이지를 이동하면 ‘깜빡’인다. (UX)</li>\n<li>매 페이지 요청마다 리로딩(새로고침) 발생(새로운 페이지를 요청할 때마다 전체 페이지를 다시 렌더링하기 때문).</li>\n<li>페이지 이동시 불필요한 템플릿도 중복해서 로딩 (성능)</li>\n<li>서버 렌더링에 따른 부하</li>\n<li>모바일 앱 개발시 추가적인 백엔드 작업 필요 (생산성)개발이 복잡해질 수 있다.</li>\n</ul>","excerpt":"SPA(Single Page Application) 라고 한다. SPA에서는 서비스에 처음 접속할 때 모든 페이지의 데이터를 다 받아온다. 그려져있는 해당 페이지를 브라우저에 렌더링한다(re-rendering). ex) React 백엔드에서 받아오는 게 아니라 그려져 있는 페이지를 이동시키면서 화면에 띄워줌. SPA의 경우 최초 로딩에는 시간이 다소 걸릴 수 있으나 페이지를 이동할 때 걸리는 시간이 MPA에 비하여 압도적으로 짧다. 👍 SPA 장점 자연스러운 사용자 경험 (UX) 전체 페이지를 업데이트 할 필요가 없기 때문에 빠르고 ‘깜빡’ 거림이 없다. 필요한 리소스만 부분적으로 로딩 (성능) SPA의 Application은 서버에게 정적리소스를 한 번만 요청한다. 그리고 받은 데이터는 전부 저장해놓는다. (캐시=Cache) 서버의 템플릿 연산을 클라이언트로 분산 (성능) 컴포넌트별 개발 용이 (생산성) 모바일 앱 개발을 염두에 둔다면 동일한 API를 사용하도록 설계 가능 (생산…","frontmatter":{"date":"August 26, 2022","title":"SPA vs MPA","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_13/"}},"next":{"id":"96e7f4e9-2d4c-5ae5-998d-5afd99a0b109","html":"<p>React에서는 전역상태를 관리하는 라이브러리들이 상당히 존재한다. 상태관리 라이브러리 중 바이블(?)이라고 불리는 Redux가 존재한다.(현재는 Redux toolkit을 사용하길 권장함)</p>\n<p>이 Redux를 포함하여 많은 상태관리 라이브러리가 존재하는데, 하나씩 알아보도록 하자.</p>\n<h3 id=\"전역상태에-대한-정의\" style=\"position:relative;\"><a href=\"#%EC%A0%84%EC%97%AD%EC%83%81%ED%83%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EC%9D%98\" aria-label=\"전역상태에 대한 정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>전역상태에 대한 정의</h3>\n<p>상태관리 라이러리를 소개하기 전, 먼저 <code class=\"language-text\">전역상태가 무엇인가</code>에 대해 얘기해보자.</p>\n<ul>\n<li>우리가 다루어야할 상태가 무엇이 있는지를 정의하고 이를 구분할 수 있어야 함.</li>\n<li>어떤 상태가 들어가야하는지 기획을 생각하고 파악해볼 필요가 있음.</li>\n<li>상태를 나눌 필요가 없다면? 굳이 상태관련 라이브러리를 사용해야 하는가?</li>\n</ul>\n<h3 id=\"글로벌-상태-관리란\" style=\"position:relative;\"><a href=\"#%EA%B8%80%EB%A1%9C%EB%B2%8C-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC%EB%9E%80\" aria-label=\"글로벌 상태 관리란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>글로벌 상태 관리란?</h3>\n<p>전역 상태관리를 사용하면 여러 구성 요소간에 데이터를 쉽게 전달/조작할 수 있습니다. (영구 전달 체인 끊기)</p>\n<h3 id=\"옵션비교\" style=\"position:relative;\"><a href=\"#%EC%98%B5%EC%85%98%EB%B9%84%EA%B5%90\" aria-label=\"옵션비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>옵션비교</h3>\n<h4 id=\"context-api\" style=\"position:relative;\"><a href=\"#context-api\" aria-label=\"context api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Context API</h4>\n<p>Contex API는 React 16.3버전에서 출시된 옵션이다. 컨텍스트 API는 구성 요소 트리에서 쉽게 전달할 수 있는 전역 데이터를 생성한다. 이것은 데이터를 전달하기 위해 props가 있는 구성 요소 트리를 통과해야 하는 \n“props Drilling”의 대안으로 사용되고 있다.</p>\n<ul>\n<li>\n<p>장점</p>\n<ul>\n<li>사용의 간편함</li>\n<li>타사 라이브러리가 필요하지 않다.</li>\n<li>번들 크기를 늘려주지 않는다.</li>\n<li>기본적으로 React 기반으로 구워진다.</li>\n</ul>\n</li>\n<li>\n<p>단점</p>\n<ul>\n<li>속도가 느리다. 컨텍스트의 값이 변경되면 실제로 사용하는지 여부에 관계없이 이 컨텍스트를 사용하는 모든 구성 요소가 다시 랜더링된다. 따라서 빈도가 높은 업데이트 또는 컨텍스트를 통해 전체 응용 프로그램 상태를 공유하는 것은 과도한 렌더링 수명 주기를 유발하며 매유 비효율적으로 로케일, 테마 변경, 사용자 인증 등과 같은 빈도가 낮은 업데이트에만 적합하다</li>\n<li>렌더 성능상의 이슈가 있다</li>\n<li>Context를 사용하면 컴포넌트를 재사용하기가 어려워진다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"redux\" style=\"position:relative;\"><a href=\"#redux\" aria-label=\"redux permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redux</h4>\n<p>Redux는 React 앱의 상태를 중앙 집중식으로 저장하고 관리하는 데 사용되는 상태 관리 라이브러리이다. Redux는 앱의 모든 상태를 하나의 전역화된 상태 객체로 추상화한다.</p>\n<ul>\n<li>\n<p>Redux의 세가지 원칙</p>\n<ul>\n<li>전체 상태 값이 하나의 자바스크립트 객체로 표현된다.</li>\n<li>상태 값은 읽기 전용의 불변 객체로 관리한다.</li>\n<li>오직 순수함수에 의해서만 상태값을 변경할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>장점</p>\n<ul>\n<li>상태 개체의 일부가 업데이트되면 해당 상태를 사용하는 구성 요소만 다시 렌더링 된다.</li>\n<li>Redux는 자주 업데이트되는 앱이 있을때 사용하면 더욱 효율적이다.</li>\n<li>저장소가 업데이트되면 변경되지 않고 업데이트된다. 이전 저장소는 새 상태 값으로 복사된다.이를 통해서 이전 업데이트 및 업데이트 기록을 따라 이동하는 시간과 같은 항목을 추적해 디버깅에 도움을 줄 수 있다. 이렇게 한다면 Redux를 더욱 쉽게 테스트 + 유지 보수 관리 및 확장을 할 수 있다.</li>\n<li>Redux기반으로한 디버깅 도구: Redux DevTools</li>\n<li>상태 관리 라이브러리에서 Redux는 가장 큰 커뮤니티 지원을 제공한다.</li>\n</ul>\n</li>\n<li>\n<p>단점</p>\n<ul>\n<li>많은 상용구와 복잡한 구조를 가진다.</li>\n<li>설치해야할 타사 라이브러리 존재하고 그만큼 번들 크기가 증가한다</li>\n<li>불변 저장소의 단점으로 저장소가 거대한 json 파일로 빠르게 변할 수 있다는 점\n작성해야할 코드가 상대적으로 많아진다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"mobx\" style=\"position:relative;\"><a href=\"#mobx\" aria-label=\"mobx permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MobX</h4>\n<p>MobX는 상태 관리를 간단하게 만들기 위한 기능적 반응 프로그래밍(예: @observable)을\n적용하는 상태관리 라이브러리이다.</p>\n<ul>\n<li>\n<p>장점</p>\n<ul>\n<li>Mobx는 @observable을 사용하여 구독을 통해 변경 사항을 자동으로 추적한다.</li>\n<li>이것은 Redux 개발자가 리듀서에서 데이터를 복제하고 변경 불가능하게 업데이트하는 오버헤드를 제거한다.</li>\n<li>Redux에 비해서 상용구가 적다. 그만큼 배우기 쉬움</li>\n<li>MobX는 여러 저장소를 지원하지만 Redux는 단일 저장소를 허용한다. 이를 통해서 UI상태와 도메인 상태(서버 API 데이터)에 대한 별도의 저장소를 가질 수 있다. UI 상태가 별도로 유지되기 떄문에 도메인 상태를 서버 데이터와 일치하게 유지하고 서버에 연결하는 것을 간단하게 만들 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>단점</p>\n<ul>\n<li>업데이트 중에 MobX 상태를 덮어쓴다. 구현하기에는 쉽지만 저장소가 훨씬 덜 예측가능하기 때문에 테스트 및 유지 관리가 어려울 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"swr\" style=\"position:relative;\"><a href=\"#swr\" aria-label=\"swr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SWR</h3>\n<p>SWR은 Next.js에서 개발한 zeit 그룹에서 사용하는 라이브러리입니다. \nSWR은 맨처음 cache(캐시)로 부터 받아온 데이터 즉, 오래된 정보를 먼저 리턴 해주고 그 다음 fetch를 한 다음 마지막으로 업데이트된 데이터를 다시 리턴해줍니다. 이러한 로직을 통해서 UX의 향상을 만들어 낼 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Home</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">,</span> error <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useSWR</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/home'</span><span class=\"token punctuation\">,</span> fetcher<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>ERROR...&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>isLoading....&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div>{data.name}&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>\n<p>장점</p>\n</li>\n<li>\n<p>데이터가 캐싱된다.</p>\n</li>\n<li>\n<p>SWR은 자동으로 재검증을 해준다.</p>\n</li>\n<li>\n<p>Revalidate on Focuspage에 re-focus하던가 tab을 변경했을 때, SWR은 자동으로 데이터를 재검증한다. 이로써 최신 상태로 데이터를 즉시 동기화하는 데 유용오래된 모바일 탭 또는 절전 모드가 된 노트북과 같은 환경에서 데이터를 새로 고치는 데 유용\nRevalidate on IntervalSWR은 설정한 Interval 이후 데이터를 자동으로 다시 가져 오는 옵션을 제공</p>\n</li>\n<li>\n<p>Revalidate on Reconnect데이터가 항상 최신 상태인지 확인하기 위해 SWR은 - 네트워크가 복구 될때 자동으로 재검증 사용자가 다시 온라인 상태가 될때 유효성을 다시 확인할 수 있도록 한다.</p>\n</li>\n</ul>\n<p>SWR을 이용하면 의존데이터를 쉽게 가져올 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function MyProjects() {\nconst { data: user } = useSWR(`api/user`)\nconst { data: projects } = useSWR(() => 'api/projects?uid=' + user.id)\n\nif (!projects) return \"loading...\"\nreturn 'You have ' + projects.length + 'projects'\n}</code></pre></div>","frontmatter":{"date":"August 26, 2022","title":"React 상태관리","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_14/"}},"prev":{"id":"953ed6f8-7042-5b17-a1ed-a013c5e08ae8","html":"<p>클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. 클로저를 이해하려면 자바스크립트가 어떻게 변수의 유효범위를 지정하는지(Lexical scoping)를 먼저 이해해야 한다.</p>\n<h3 id=\"렉시컬-스코프lexical-scope\" style=\"position:relative;\"><a href=\"#%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84lexical-scope\" aria-label=\"렉시컬 스코프lexical scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렉시컬 스코프(Lexical Scope)</h3>\n<p>렉시컬 스코프란 중첩된 함수 그룹에서 내부 함수가 상위 범위의 변수 및 기타 리소스에 액세스 할 수 있음을 의미한다.</p>\n<p>즉, 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정한다는 뜻이며, 가장 중요한 점은 함수를 어디서 호출하는 지가 아니라 어디에 선언하였는지에 따라 결정된다.</p>\n<p>다른 말로, 정적 스코프(Static Scope)라고 부르기도 한다.</p>\n<h3 id=\"클로저closure\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80closure\" aria-label=\"클로저closure permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클로저(Closure)</h3>\n<p>이제 다음 예제를 보자</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">makeFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Mozilla'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">displayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> displayName<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> myFunc <span class=\"token operator\">=</span> <span class=\"token function\">makeFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//myFunc변수에 displayName을 리턴함</span>\n<span class=\"token comment\">//유효범위의 어휘적 환경을 유지</span>\n<span class=\"token function\">myFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//리턴된 displayName 함수를 실행(name 변수에 접근)</span></code></pre></div>\n<p>이 코드는 바로 전의 예제와 완전히 동일한 결과가 실행된다. 하지만 흥미로운 차이는 displayName()함수가 실행되기 전에 외부함수인 makeFunc()로부터 리턴되어 myFunc 변수에 저장된다는 것이다.</p>\n<p>한 눈에 봐서는 이 코드가 여전히 작동하는 것이 직관적으로 보이지 않을 수 있다. 몇몇 프로그래밍 언어에서, 함수 안의 지역 변수들은 그 함수가 처리되는 동안에만 존재한다. makeFunc() 실행이 끝나면(displayName함수가 리턴되고 나면) name 변수에 더 이상 접근할 수 없게 될 것으로 예상하는 것이 일반적이다.</p>\n<p>하지만 위의 예시와 자바스크립트의 경우는 다르다. 그 이유는 자바스크립트는 함수를 리턴하고, 리턴하는 함수가 클로저를 형성하기 때문이다. 클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. 이 환경은 클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수로 구성된다. 첫 번째 예시의 경우, myFunc은 makeFunc이 실행 될 때 생성된 displayName 함수의 인스턴스에 대한 참조다. displayName의 인스턴스는 변수 name이 있는 어휘적 환경에 대한 참조를 유지한다. 이런 이유로 myFunc가 호출될 때 변수 name은 사용할 수 있는 상태로 남게 되고 “Mozilla” 가 alert에 전달된다.</p>","frontmatter":{"date":"August 26, 2022","title":"closure","categories":"js","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_16/"}},"site":{"siteMetadata":{"siteUrl":"https://leedawnn.github.io","comments":{"utterances":{"repo":"leedawnn/leedawnn.github.io"}}}}},"pageContext":{"slug":"/codecamp_blog_13/","nextSlug":"/codecamp_blog_14/","prevSlug":"/codecamp_blog_16/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}