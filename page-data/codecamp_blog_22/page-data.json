{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/codecamp_blog_22/",
    "result": {"data":{"cur":{"id":"925bc7be-11a4-5866-8642-20b2220e0557","html":"<h3 id=\"docker\" style=\"position:relative;\"><a href=\"#docker\" aria-label=\"docker permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Docker</h3>\n<p>부팅 등 <strong>운영체제의 커널</strong>을 공유하는 가상머신. OS 전체를 다운받는 것이 아니라 훨씬 가볍고, 빠르다.\n또한, Node와 Mysql 등의 프로그램이 이미 설치된 Docker도 만들 수 있다.</p>\n<p>개발 환경을 똑같이 세팅했다고 하더라도 운영체제에 따라서 달라지는 경우가 많다.\n따라서 운영체제에 상관없이 동일한 개발환경을 위해 <code class=\"language-text\">**Docker**</code>를 사용한다.</p>\n<p>세팅이 완료되어 있는 Dockerfile만 다운 받으면 끝남. Window나 Mac을 사용해도 리눅스로 통일되니까 충돌이 없음.</p>\n<p><strong>정리</strong></p>\n<ol>\n<li>개발/배포환경 통일</li>\n<li>프로그램 미리 설치</li>\n<li>가벼운 가상컴퓨터</li>\n</ol>\n<p><strong>Docker</strong> <strong>Image</strong>(<strong>이미지</strong>)</p>\n<p>특정 프로세스를 실행하기 위한(즉, 컨테이너 생성(실행)에 필요한) 모든 파일과 설정값(환경)을 지닌 것으로, 더 이상의 의존성 파일을 컴파일하거나 이것저것 실치 할 필요 없는 상태의 파일.</p>\n<p><strong>Docker-compose</strong></p>\n<p>여러 도커파일을 묶을 때 사용.</p>","excerpt":"Docker 부팅 등 운영체제의 커널을 공유하는 가상머신. OS 전체를 다운받는 것이 아니라 훨씬 가볍고, 빠르다.\n또한, Node와 Mysql 등의 프로그램이 이미 설치된 Docker도 만들 수 있다. 개발 환경을 똑같이 세팅했다고 하더라도 운영체제에 따라서 달라지는 경우가 많다.\n따라서 운영체제에 상관없이 동일한 개발환경을 위해 를 사용한다. 세팅이 완료되어 있는 Dockerfile만 다운 받으면 끝남. Window나 Mac을 사용해도 리눅스로 통일되니까 충돌이 없음. 정리 개발/배포환경 통일 프로그램 미리 설치 가벼운 가상컴퓨터 Docker Image(이미지) 특정 프로세스를 실행하기 위한(즉, 컨테이너 생성(실행)에 필요한) 모든 파일과 설정값(환경)을 지닌 것으로, 더 이상의 의존성 파일을 컴파일하거나 이것저것 실치 할 필요 없는 상태의 파일. Docker-compose 여러 도커파일을 묶을 때 사용.","frontmatter":{"date":"August 26, 2022","title":"Docker","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_22/"}},"next":{"id":"849b9339-0d0b-55f4-92da-db730f3b15ac","html":"<h3 id=\"페이지네이션pagination\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98pagination\" aria-label=\"페이지네이션pagination permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지네이션(pagination)</h3>\n<p>페이지네이션(pagination)은 여러 개의 게시물을 보여주는 웹사이트에서 보통 화면 하단에서 흔히 볼 수 있는 UI이다.</p>\n<h3 id=\"페이지네이션-알고리즘\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"페이지네이션 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지네이션 알고리즘</h3>\n<p>꼭 React가 아니라도 어떤 프론트앤드 라이브러리를 사용하든 클라이언트 단에서 페이지네이션을 처리하려면 관련 알고리즘을 이해해두는 것이 좋다.</p>\n<p>먼저 게시물을 여러 페이지에 나눠서 표시하려면 총 몇 개의 페이지가 필요한지를 알아야한다. 총 게시물 수를 페이지 당 표시할 게시물의 수로 나눈 뒤 올림을 하면 몇 개의 페이지가 필요한지를 계산할 수 있다.</p>\n<p>예를 들어, 총 37개의 게시물이 있고, 페이지 당 10개의 게시물을 표시하려고 한다면, 37 / 10 = 3.7, 여기서 올림하여 결국 4개의 페이지가 필요하게 된다. (1~3 페이지에는 10개의 게시물이 표시되고, 4페이지에는 7개의 게시물이 표시가 되겠쥬?)</p>\n<p>두번째로 알아야할 부분은 현재 페이지 번호를 기준으로 표시해줘야할 게시물들의 범위, 즉, 해당 페이지의 첫 게시물의 위치(index)를 알아야하는데, 페이지 번호에서 1을 뺀 후에 페이지 당 표시할 게시물의 수를 곱하면 첫 게시물의 위치를 계산할 수 있다. (마지막 게시물의 위치는 첫 게시물의 위치에서 단순히 페이지 당 표시할 게시물의 수만 더해주면 되겠쥬?)</p>\n<h3 id=\"무한-스크롤infinite-scroll\" style=\"position:relative;\"><a href=\"#%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4infinite-scroll\" aria-label=\"무한 스크롤infinite scroll permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>무한 스크롤(Infinite Scroll)</h3>\n<p>무한 스크롤(Infinite Scroll)이란 사용자가 특정 페이지 하단에 도달했을 때, API가 호출되며 콘텐츠가 끊기지 않고 계속 로드되는 사용자 경험 방식이다. 페이지를 클릭하면 다음 페이지 주소로 이동하는 페이지네이션(Pagination)과 달리, 한 페이지에서 스크롤만으로 새로운 콘텐츠를 보여주게 되므로, 많은 양의 콘텐츠를 스크롤하여 볼 수 있는 장점이 있다.</p>","frontmatter":{"date":"August 26, 2022","title":"Pagination vs Infinite Scroll","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_20/"}},"prev":{"id":"574422a8-cdcd-59b4-9e98-b9dfff7a32b9","html":"<h3 id=\"http\" style=\"position:relative;\"><a href=\"#http\" aria-label=\"http permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP</h3>\n<p>HTTP는 Hyper Text Transfer Protocol의 줄임말으로써 서버와 클라이언트간에 데이터를 주고 받는 프로토콜입니다. HTTP는 텍스트, 이미지,영상, JSON 등등 거의 모든 형태의 데이터를 전송할 수 있다.</p>\n<p>세상에 등장한지 벌써 30년이나 된 HTTP는 1997년 만들어진 HTTP/1.1가 가장 보편화 되어있으며, 현재는 HTTP/2를 거쳐 HTTP/3까지 개발된 상태입니다. TCP를 개선해서 만들어진 UDP가 HTTP/3 기술에 사용된다.</p>\n<h3 id=\"http는-보안적으로-안전한가\" style=\"position:relative;\"><a href=\"#http%EB%8A%94-%EB%B3%B4%EC%95%88%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%95%88%EC%A0%84%ED%95%9C%EA%B0%80\" aria-label=\"http는 보안적으로 안전한가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP는 보안적으로 안전한가?</h3>\n<p>HTTP 통신은 클라이언트와 서버간의 통신에 있어서 별다른 보안 조치가 없기때문에 만약 누군가 네트워크 신호를 가로챈다면 HTTP의 내용은 그대로 외부에 노출된다. 중요 정보가 없는 소규모의 프로젝트라면 문제가 되지 않겠지만 고객의 개인정보나 비밀을 취급하는 대규모 서비스라면 큰 보안적 허점이 될 것이다. 이런 문제를 해결하기 위해 등장한 것이 HTTPS이다.</p>\n<h3 id=\"https\" style=\"position:relative;\"><a href=\"#https\" aria-label=\"https permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS</h3>\n<p>요즘은 거의 모든 사이트의 주소창에서 자물쇠 표시를 볼 수 있다. HTTPS가 적용되었다는걸 알려주는게 바로 자물쇠이다. HTTPS가 옛날부터 보편화되어있지는 않았다. 처음에는 전자상거래 등 고객의 중요 정보를 다루는 사이트 위주로 사용됨.</p>\n<p>그러다가 2014년 구글에서는 HTTP를 HTTPS로 변환하라고 권고하기 시작했다. 귀찮은 작업을 시킬때는 보상이 있어야겠쥬? 구글은 HTTPS를 적용하는 사이트들에게 SEO(검색 엔진 최적화)에 있어서 가산점을 주겠다고함. 사용자 정보의 안전성도 보장받고, 사용자들의 웹사이트 유입도 늘릴수 있으니 HTTPS로 변환할 이유는 충분했을 것.</p>\n<h3 id=\"https는-어떤-방식으로-보안-이슈를-해결하는가\" style=\"position:relative;\"><a href=\"#https%EB%8A%94-%EC%96%B4%EB%96%A4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EC%95%88-%EC%9D%B4%EC%8A%88%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"https는 어떤 방식으로 보안 이슈를 해결하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS는 어떤 방식으로 보안 이슈를 해결하는가?</h3>\n<p>기존의 HTTP 프로토콜은 전송계층의 TCP위에서 동작한다. 여기서 SSL(Secure Sockets Layer)이라는 보안계층이 전송계층 위에 올라감. HTTPS는 SSL 위에 HTTP를 얹어서 보안이 보장된 통신을 하는 프로토콜이다. 이 통신 방식을 SSL 암호화 통신 이라고도 한다. SSL 암호화 통신은 공개키 암호화 방식이라는 알고리즘을 통해 구현된다.</p>","frontmatter":{"date":"August 26, 2022","title":"https vs http","categories":"frontend","author":"leedawn","emoji":"🧐"},"fields":{"slug":"/codecamp_blog_21/"}},"site":{"siteMetadata":{"siteUrl":"https://leedawnn.github.io","comments":{"utterances":{"repo":"leedawnn/leedawnn.github.io"}}}}},"pageContext":{"slug":"/codecamp_blog_22/","nextSlug":"/codecamp_blog_20/","prevSlug":"/codecamp_blog_21/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}